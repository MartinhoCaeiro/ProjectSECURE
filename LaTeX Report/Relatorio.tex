\documentclass[a4paper]{article}
\usepackage[portuguese]{babel}
\usepackage[backend=biber, style=apa, citestyle=apa, language=portuguese]{biblatex}
\usepackage{csquotes}
\addbibresource{Recursos/referencias.bib}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{setspace}
\usepackage{siunitx} % Required for alignment
\sisetup{
  round-mode          = places, % Rounds numbers
  round-precision     = 2, % to 2 places
}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{karnaugh-map}
\usepackage[section]{placeins}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{titling}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{xcolor}
\usepackage{indentfirst}
\usepackage{array}
\usepackage{wrapfig} % Coloca isto no preâmbulo
\usepackage{soul}
\usepackage{afterpage}
\usepackage[toc,page]{appendix}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}


% Comando para criar uma página vazia
\newcommand\myemptypage{
    \null
    \thispagestyle{empty}
    \addtocounter{page}{-1}
    \newpage
}

% Página de título principal
\newcommand{\firsttitlepage}{
    \begin{titlepage}
        \centering
        
        % Logos superior
        \begin{figure}[h!]
            \centering
            \includegraphics[width=6cm]{Recursos/Logos/LOGO_IPB} % Substitua pelo caminho da imagem
            \vspace{0.5cm}
        \end{figure}    
        % Informações da instituição
        \large\textbf{INSTITUTO POLITÉCNICO DE BEJA} \\
        \large\textbf{Escola Superior de Tecnologia e Gestão} \\
        \large\textbf{Licenciatura em Engenharia Informática} \\
        \large\textbf{Projeto Final de Curso} \\
        
        
        % Título do projeto
        {\Huge \textbf{Desenvolvimento de um sistema de comunicações seguras }} \\
        
        \vspace{1cm}
        
        % Autores
    
        \large Martinho José Novo Caeiro - 23917 \\
        \large Paulo António Tavares Abade - 23919 \\
        \large Rafael Conceição Narciso - 24473 \\
        
        \vfill
        
        % Logo inferior
        \begin{figure}[h!]
            \centering
            \includegraphics[width=6cm]{Recursos/Logos/IPBejaESTIG.jpg} % Substitua pelo caminho da imagem
        \end{figure}
        
        % Local e data
        {\large Beja, julho de 2025}
    \end{titlepage}
}

\newcommand{\secondtitlepage}{
    \begin{titlepage}
        \centering
        \vspace*{1cm}
        
        % Informações da instituição
        \large\textbf{INSTITUTO POLITÉCNICO DE BEJA} \\
        \large\textbf{Escola Superior de Tecnologia e Gestão} \\
        \large\textbf{Licenciatura em Engenharia Informática} \\
        \large\textbf{Projeto Final de Curso} \\
        
        \vspace{2cm}
        
        % Título do projeto
        {\Huge \textbf{Desenvolvimento de um sistema de comunicações seguras }} \\
        
        \vspace{1.5cm}
        
        % Autores
        \large Martinho José Novo Caeiro - 23917 \\
        \large Paulo António Tavares Abade - 23919 \\
        \large Rafael Conceição Narciso - 24473 \\

        \vspace{2cm}

        % Orientador
        \large Orientador: Professor Rui Silva \\
        
        \vfill
        
        % Local e data
        {\large Beja, julho de 2025}
    \end{titlepage}
}

\begin{document}


\pagenumbering{gobble} % Oculta numeração da página

% Primeira página de título
\firsttitlepage

\secondtitlepage


% Abstract
\section*{\LARGE\textbf{\textit{Resumo}}}

Neste relatório será abordado o processo de criação de uma solução de comunicações seguras,
que permita a troca de mensagens de texto entre os seus utilizadores.
Este relatório foi realizado no âmbito da Unidade Curricular de
Estágio ou Projeto (\cite{pagep}).


\vspace{1cm}
% Keywords
\textbf{Keywords:} aplicações, cibersegurança, comunicações, criptografia, c\#, python, bash, almalinux, wireguard, sqlite, kotlin
\newpage
%--------------------------------------------------------------------------------------------------------------------------------------

\section*{\LARGE\textbf{\textit{Abstract}}}

In this report, we will address the creation process of a secure communication
solution that allows text message exchange between its users.
This report was carried out within the scope of the
Curricular Unit of Internship or Project (\cite{pagep}).


\vspace{1cm}
% Keywords
\textbf{Keywords:} applications, cybersecurity, communications, cryptography, c\#, python, bash, almalinux, wireguard, sqlite, kotlin
\renewcommand{\contentsname}{Índice}       % Título do sumário
\renewcommand{\listfigurename}{Índice de Figuras} % Título da lista de figuras

% Início do conteúdo do relatório
\newpage
\doublespacing
\tableofcontents
\newpage
\listoffigures
\doublespacing

\newpage
\pagenumbering{arabic}

\section{Introdução}\label{intro}
Para a realização do projeto é necessário desenvolver um sistema de comunicações seguras, que permita a troca de mensagens de texto entre os seus utilizadores.
Para tal, é necessário implementar um sistema de autenticação de utilizadores, que permita a criação de contas de utilizador e a autenticação dos mesmos.
O sistema deve ser capaz de garantir a confidencialidade, integridade e autenticidade das mensagens trocadas entre os utilizadores. As tecnologias a utilizadas
no desenvolvimento deste projeto são: WireGuard (\cite{wireguard}), SQLite (\cite{sqlite}), C\# (\cite{csharp}), Kotlin (\cite{kotlin}), Python (\cite{python}),
Bash (\cite{bash}), AlmaOS (\cite{almaos}). Em relação a criptografia, serão utilizados os algoritmos Rijndael (vencedor do AES) e
Serpent (segundo lugar do AES), que são algoritmos de criptografia simétrica.

Para este projeto, foi decidido utilizar uma variação da metodologia do \textit{SCRUM}, onde eram realizadas reuniões semanais ao ínicio, e depois
foi sendo feito para ocorrer mais tempo entre reuniões, de forma a que fosse possível ter mais tempo para o desenvolvimento das
tarefas. Os três membros da equipa foram divididos entre as três áreas do projeto, nomeadamente: desenvolvimento da aplicação Windows,
desenvolvimento da aplicação Android e por último, a configuração da infraestrutura da rede.

O cronograma do projeto foi dividido em duas fases principais: Análise de Requisitos, Desenvolvimento, como é possível
ver na figura \ref{fig:project_schedule}. O relatório foi modificado a cada semana, acrescentando novas informações e
atualizações sobre o progresso do projeto.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/Cronograma.png}
	\caption{Cronograma do Projeto}
	\label{fig:project_schedule}
\end{figure}

Este projeto ficou guardado nos repositórios do GitHub da equipa, onde pode ser consultado por outros alunos e professores, a partir do seguinte
link:\\ \url{https://github.com/MartinhoCaeiro/Projeto-Cripto} \&  \url{https://github.com/NarcisoUNK/ProjectFinal_ANDROID}.
%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Analise de Requisitos}\label{analise}
Para a realização deste projeto, foram necessários os seguintes requisitos:
\begin{itemize}
	\item \textbf{Requisitos Funcionais:}
	      \begin{itemize}
		      \item O sistema deve permitir a criação de contas de utilizador.
		      \item O sistema deve permitir a autenticação de utilizadores.
		      \item O sistema deve permitir o envio e receção de mensagens entre utilizadores.
		      \item O sistema deve garantir a confidencialidade, integridade e autenticidade das mensagens trocadas.
	      \end{itemize}
	\item \textbf{Requisitos Não Funcionais:}
	      \begin{itemize}
		      \item O sistema deve ser seguro e resistente a ataques.
		      \item O sistema deve ser fácil de usar e intuitivo.
		      \item O sistema deve ser escalável e capaz de suportar um grande número de utilizadores.
	      \end{itemize}
\end{itemize}

Foram ainda analisadas outras aplicações de troca de mensagens seguras, como o \textit{WhatsApp} (\cite{whatsapp}) 
e \textit{Telegram} (\cite{telegram}), para compreender como estas funcionam. Chegando à conclusão de que utilizam
uma encriptação de ponta a ponta para garantir a segurança das mensagens. Neste projeto, será implementada uma abordagem 
bastante semelhante, porém com a integração da VPN.

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Tecnologias Utilizadas}\label{tecnologias}
Para o desenvolvimento deste projeto, foram utilizadas as seguintes tecnologias:
\begin{itemize}
	\item \textbf{Linguagens de Programação:} C\#, Kotlin
	\item \textbf{Frameworks:} .NET, WireGuard
	\item \textbf{Base de Dados:} SQLite
	\item \textbf{Criptografia:} Rijndael (Vencedor AES), Serpent (Segundo lugar AES)
	\item \textbf{Ferramentas de Desenvolvimento:} Git, Visual Studio Code, Android Studio
	\item  \textbf{Serviços de Hospedagem:} GitHub
\end{itemize}

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Arquitetura do Sistema}\label{arquitetura}
O sistema é composto por uma aplicação que funcionará como um chat, onde os utilizadores que estiverem registado na VPN poderão comunicar entre si.
Dentro da aplicação, os utilizadores podem saber quem está associado a um endereço IP da VPN, e assim enviar mensagens para esse utilizador.
Ao enviar uma mensagem, a aplicação irá contatar o servidor da VPN, para obter o caminho até ao destinatário, e assim enviar a mensagem.
Essa mensagem será encriptada antes de ser enviada, para garantir a confidencialidade e integridade da mensagem. Existe a variação
da encriptação utilizada na mensagem, de acordo com uma lógica pré-definida na aplicação, sendo que os métodos de encriptação utilizados são o AES
e o Serpent.
\subsection{Encriptação do Sistema}
Sendo assim, a parte de encriptação das mensagens será feita como está demonstrado na figura \ref{fig:encryption_process}. A mensagem
será encriptada consoante um número pseudo-aleatório gerado pela aplicação, sendo assim escolhido o algoritmo de encriptação a utilizar naquele momento, o AES256 ou Serpent.
Para encriptar, é necessário fornecer também uma chave de encriptação. Nesta fase, a chave de encriptação é "\textit{\textbf{Spartacus}}". É importante destacar que o seletor 
está ofuscado, de forma a dificultar a sua identificação, a partir de uma máscara criada através da chave (\textit{salt}) e do número pseudo-aleatório.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/Encripta.png}
	\caption{Processo de Encriptação das Mensagens}
	\label{fig:encryption_process}
\end{figure}

\newpage

Para desencriptar, é necessário fazer o processo inverso. Desta forma, o número pseudo-aleatório está anexado à mensagem encriptada,
permitindo assim descobrir qual o algoritmo de encriptação utilizado. É possível ver este processo na figura \ref{fig:decryption_process}.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/Decripta.png}
	\caption{Processo de Decriptação das Mensagens}
	\label{fig:decryption_process}
\end{figure}

\subsection{Estrutura do Sistema}
A estrutura do sistema é focada na troca de informação por dentro da VPN, podendo ser representada 
na seguinte figura \ref{fig:system_architecture}: 
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Recursos/SistemaFisico.png}
    \caption{Arquitetura do Sistema}
    \label{fig:system_architecture}
\end{figure}
%---------------------------------------------------------------------------------------------------------------------------

\section{Módulos do Sistema}\label{modulos}

\subsection{Interface do Sistema}
A interface para computador será desenvolvida em C\#, cuja qual é uma linguagem rápida e fácil de aprender, e que permite o desenvolvimento de aplicações desktop de forma rápida e eficiente, enquanto 
que a interface para Android será desenvolvida em Kotlin, que é uma linguagem de programação moderna e concisa, que permite o desenvolvimento de aplicações Android de forma rápida e eficiente.
Esta interface é composta por 4 ecrãs principais:
\begin{itemize}
	\item \textbf{Ecrã de Login:} onde o utilizador pode autenticar-se na aplicação utilizando as suas credenciais, tambem é possivel ver o status da ligação WireGuard.
	\item \textbf{Ecrã de Lista de Chats:} onde o utilizador pode ver a lista de chats existentes, bem como criar novos chats.
	\item \textbf{Ecrã de Chat:} onde o utilizador pode enviar e receber mensagens de outros utilizadores.
	\item \textbf{Ecrã de Configuração WireGuard:} onde o utilizador pode criar um ficheiro para configuração do WireGuard.
\end{itemize}

\subsection{Módulo da VPN}
A VPN estará alojada num servidor com o sistema operativo AlmaOS 8.10 (\cite{almaos}), e será responsável por gerir as ligações dos utilizadores à VPN,
bem como a autenticação dos mesmos. O serviço escolhido foi o WireGuard, que é um serviço de VPN de código aberto,
leve e de alto desempenho, que utiliza criptografia moderna para garantir a segurança das comunicações. É necessário configurar previamente o WireGuard no dispositivo
do utilizador, para que este possa estabelecer uma ligação à VPN.


\newpage 
\subsection{Base de Dados}
A base de dados será utilizada para armazenar as informações dos utilizadores, como as suas credenciais, bem como as mensagens trocadas entre os utilizadores, esta será implementada utilizando o SQLite.
A base de dados irá ter a seguinte estrutura:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/ProjectSecure_DB.png}
	\caption{Estrutura da Base de Dados}
	\label{fig:db_structure}
\end{figure}

\newpage 

Sendo que a base de dados é composta por 4 tabelas, cada uma com as suas respetivas colunas,
sendo que as tabelas são:

\begin{minipage}{\textwidth}


    \begin{itemize}

        \item \textbf{User:}
              \begin{itemize}
                  \item UserID (chave primária)
                  \item Username (string)
                  \item Password (string)
              \end{itemize}

        \item \textbf{Chat:}
              \begin{itemize}
                  \item ChatID (chave primária)
                  \item Name (string)
                  \item AdminID (chave estrangeira, referência à tabela User)
              \end{itemize}

        \item \textbf{Participant:}
              \begin{itemize}
                  \item ParticipantID (chave primária)
                  \item ChatID (chave estrangeira, referência à tabela Chat)
                  \item UserID (chave estrangeira, referência à tabela User)
              \end{itemize}
              \newpage
        \item \textbf{Message:}
              \begin{itemize}
                  \item MessageID (chave primária)
                  \item ParticipantID (chave estrangeira, referência à tabela Participant)
                  \item Content (string)
                  \item Date (data e hora da mensagem)
                  \item SenderUserID (chave estrangeira, referência à tabela Participant)
              \end{itemize}
    \end{itemize}

    % Inserir imagem e legenda manualmente dentro do minipage
    \vspace{1em}
    \centering
    \includegraphics[width=0.8\textwidth]{Recursos/ProjectSecure_DB.png}
    \begin{center}
        \small \textbf{Figura:} Estrutura da Base de Dados
    \end{center}

\end{minipage}

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Desenvolvimento}\label{desenvolvimento}
\subsection{Interface para Computador}
Para o desenvolvimento da interface para computador, foi utilizado o Visual Studio Code, que é um ambiente de desenvolvimento integrado (IDE) da Microsoft.

\subsubsection{Ecrã de Login}
O ecrã de login é composto por um formulário onde o utilizador pode inserir as suas credenciais, e um botão para autenticar-se na aplicação.
Caso não tenha uma conta criada apenas tem que preencher o formulario e clicar no botão de criar conta, esta ação só é possivel com o Wireguard ativado.
Também é possivel ver o estado da ligação WireGuard, caso esteja ligado ou desligado.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/LoginPC1.png}
        \caption{WireGuard Ativado}
    \label{fig:login_pc_img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/LoginPC2.png}
        \caption{Wireguard Desativado}
    \label{fig:login_pc_img2}
    \end{subfigure}
    \caption{Ecrã de Login - Computador}
    \label{fig:login_pc_duas_imagens}
\end{figure}

\newpage
\subsubsection{Ecrã de Lista de Chats}
O ecrã de lista de chats é composto por uma lista de chats existentes e um botão para criar novos chats, este só pode ser criado com o WireGuard ativado.
No seu canto superior direito, existe um botão para aceder às definições da aplicação, onde o utilizador pode configurar se quer a aplicação em modo escuro ou claro,
e no seu canto inferior esquerdo existe um botão para terminar sessão caso deseja mudar de utilizador.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ListaPC1.png}
        \caption{WireGuard Ativado}
    \label{fig:lista_pc_img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ListaPC2.png}
        \caption{Wireguard Desativado}
    \label{fig:lista_pc_img2}
    \end{subfigure}
    \caption{Ecrã de Lista de Chats - Computador}
    \label{fig:lista_pc_duas_imagens}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Chat}
O ecrã de chat é composto por uma lista de mensagens trocadas entre os utilizadores, mensagens recebidas ficam do lado esquerdo e mensagens enviadas no lado direito.
Apenas é possivel enviar mensagens com o WireGuard ativado, para enviar uma mensagem basta escrever no campo de texto e clicar no botão de enviar.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ChatPC1.png}
        \caption{WireGuard Ativado}
    \label{fig:chat_pc_img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ChatPC2.png}
        \caption{Wireguard Desativado}
    \label{fig:chat_pc_img2}
    \end{subfigure}
    \caption{Ecrã de Chat - Computador}
    \label{fig:chat_pc_duas_imagens}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Configuração WireGuard}
O ecrã de configuração WireGuard é composto por um formulário onde o utilizador insere o seu nome, e um botão para descarregar o ficheiro de configuração do WireGuard.
\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{Recursos/WireguardPC.png} % Substitua pelo caminho da imagem
	\label{fig:wireguard_pc}
	\caption{Ecrã de Configuração WireGuard - Computador}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsection{Interface para Android}
Para o desenvolvimento da interface para Android, foi utilizado o Android Studio, que é um ambiente de desenvolvimento integrado 
(IDE) oficial para o sistema operativo Android.
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Login}
O ecrã de login é composto por um formulário onde o utilizador pode inserir as suas credenciais, e um botão para autenticar-se na aplicação. 
Este pode iniciar sessão ou criar uma conta, caso não possua uma. Também é possivel ver o estado da ligação WireGuard, caso esteja ligado 
ou desligado. Existe ainda a possibilidade de estabelecer a comunicação de uma forma mais prática para o utilizador, através do download do 
ficheiro de configuração do WireGuard.

\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/LoginAndroid.png} % Substitua pelo caminho da imagem
    \label{fig:android_login}
    \caption{Ecrã de Login - Android}
    
\end{figure}
\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de configuração do WireGuard}
Neste ecrã, o utilizador pode inserir um nome que está associado à sua ligação WireGuard. Após inserir e enviar o pedido, será 
fornecido o ficheiro de configuração do WireGuard, que pode ser importado diretamente na aplicação do WireGuard no dispositivo Android.

\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/WireguardAndroid.png} % Substitua pelo caminho da imagem
    \label{fig:android_config_wireguard}
    \caption{Ecrã de Configuração do WireGuard - Android}
    
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Lista de Chats}
O ecrã de lista de chats é composto por uma lista de conversas anteriores, onde o utilizador pode selecionar uma conversa para visualizar o seu conteúdo. 
Neste ecrã, também é possível iniciar uma nova conversa, caso o utilizador deseje.
\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/ListaAndroid.png} % Substitua pelo caminho da imagem
    \caption{Lista de Chats - Android}
    \label{fig:android_lista_chats}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Chat}
O ecrã de chat é composto por uma lista de mensagens trocadas entre os utilizadores, mensagens recebidas ficam do lado esquerdo e mensagens enviadas no lado direito.
Apenas é possivel enviar mensagens com o WireGuard ativado, para enviar uma mensagem basta escrever no campo de texto e clicar no botão de enviar.
\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/ChatAndroid.png} % Substitua pelo caminho da imagem
    \caption{Ecrã de Chat - Android}
    \label{fig:android_chat}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsection{AlmaOS - Serviço de VPN}
Para configurar corretamente o serviço de VPN, é necessário instalar o WireGuard no servidor AlmaOS 8.10,
para isso ser feito, foi necessário seguir os seguintes passos:
\begin{enumerate}
	\item Adicionar o repositório EPEL - sudo dnf install epel-release
	\item Adicionar o repositório ELREPO - sudo dnf install https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm
	\item Ativar o CodeReady Builder - sudo /usr/bin/crb enable
	\item Atualizar os metadados - sudo dnf makecache
	\item sudo dnf --enablerepo=elrepo install kmod-wireguard -y
	\item Instalar o WireGuardTools - sudo dnf install wireguard-tools -y
\end{enumerate}
Para verificar se o WireGuard está instalado corretamente, pode-se utilizar o comando \textbf{"sudo modprobe wireguard"},
se este não devolver nenhum output, significa que o WireGuard está instalado corretamente.

Agora, para configurar o WireGuard, é necessário criar as chaves de criptografia, para isso é necessário
ir para a pasta \textbf{/etc/wireguard} e executar o seguintes comando:
\begin{verbatim}
    wg genkey | tee server_private.key | wg pubkey > server_public.key
    chmod 600 server_private.key
\end{verbatim}
Isto irá gerar duas chaves, uma privada e uma pública, que serão utilizadas para autenticar os utilizadores na VPN.
\newpage
Após isso, é necessário criar o ficheiro de configuração do WireGuard, onde estará definida a configuração da VPN em si,
como o endereço IP da VPN, a porta de escuta, as chaves de criptografia, entre outros.
Para isso, é necessário criar o ficheiro \textbf{wg0.conf} na pasta \textbf{/etc/wireguard}, e adicionar o seguinte conteúdo:
\begin{verbatim}
    [Interface]
    PrivateKey = <Chave Privada do Servidor>
    Address = 10.0.0.1/24
    ListenPort = 51820
    SaveConfig = true
    [Peer]
    PublicKey = <Chave Pública do Cliente>
    AllowedIPs = 10.0.0.2/32
\end{verbatim}

Para garantir o bom funcionamento da VPN, é necessário ativar o encaminhamento de endereços IP, para assim permitir o tráfego de rede.
Para isso, é necessário fazer o seguinte comando:
\begin{verbatim}
    # Para permitir o tráfego de rede 
    echo "net.ipv4.ip_forward = 1" | sudo tee -a /etc/sysctl.conf
    sudo sysctl -p

    # Para permitir o tráfego pela porta 51820
    sudo firewall-cmd --add-masquerade --permanent
    sudo firewall-cmd --add-port=51820/udp --permanent
    sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o enp0s3 -j MASQUERADE
    sudo firewall-cmd --reload

\end{verbatim}
\newpage
Para ser possível encaminhar o tráfego de rede, é necessário adicionar uma regra ao Router para que, todos os pacotes que cheguem à porta 51820
sejam encaminhados para o servidor WireGuard.
Por fim, basta iniciar o serviço do WireGuard, para isso é necessário executar o seguinte comando:
\begin{verbatim}
    sudo systemctl enable --now wg-quick@wg0
\end{verbatim}

Para conseguir estabelecer a troca de ficheiros entre o servidor e o cliente, foi necessário implementar
um \textit{script} que gerencia as trocas de ficheiros da base de dados entre os clientes e o servidor.
Esse script foi feito em Python, utiliza a biblioteca Flask para criar uma API REST que permite a comunicação entre o cliente e o servidor.
Foi necessário permitir a porta 8000 no servidor, para que o cliente possa comunicar com o servidor.


Do lado do cada cliente, vai ser necessário configurar o WireGuard, de maneira a que apenas a informação
proveniente da aplicação desenvolvida seja enviada através da VPN, onde assim serão poupados recursos
do dispositivo que está a fazer o papel de servidor. Para isso, foi criado um \textit{script} que cria o ficheiro
de configuração do WireGuard para o cliente, sendo que este só deve adicionar o ficheiro de configuração na aplicação
do WireGuard. O \textit{script} ainda automatiza a adição do cliente nas configurações do servidor. Foi criado ainda um 
\textit{script} complementar, em Python, para ser obtido o ficheiro de configurações de maneira mais fácil para o utilizador/cliente. 
Este script segue o mesmo princípio da troca da base de dados, com a diferença de que está a utilizar a seu endereço de IP local em vez 
da VPN. Sendo assim, para obter o ficheiro de configurações, é necessário estabelecer conexão com o servidor no endereço 
\textit{192.168.1.106:9595 {nome}}, onde \textit{nome} é o nome do utilizador que quer aceder à VPN. Ao estabelecer ligação, vai ter 
um ficheiro de configurações criado por um administrador à espera de ser transferido. O administrador cria esse ficheiro com o auxilio do 
\textit{script} anterior, para conseguir limitar o acesso às comunicações caso o acesso à VPN seja comprometido.


\begin{verbatim}
    sudo firewall-cmd --add-port=8000/tcp --permanent
    sudo firewall-cmd --reload
\end{verbatim}

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Problemas Encontrados}\label{problemas}
Durante o desenvolvimento do projeto, foram encontrados alguns problemas, que foram resolvidos da seguinte forma:
%-------------------------------------------------------------------------------------------------
\subsection{Problemas de Conexão}
Logo no inicio da implementação da VPN foi necessário achar uma solução para a configuração de encaminhamento de pacotes, pois o servidor Linux
não possui um endereço IP público próprio. Para contornar este problema, foi necessário configurar o encaminhamento de pacotes no router, de forma
a que todos os pacotes que chegassem à porta 51820 fossem encaminhados para o servidor Linux, e este resolveria a situação encaminhando o resto dos pacotes pela VPN.\\
Outro problema encontrado foi a dificuldade em encontrar uma maneira para estabelecer a conexão pela primeira vez, ou seja, enviar o ficheiro de configuração
da VPN para o dispositivo do utilizador, de forma a que este pudesse estabelecer a conexão com o servidor. Para resolver este problema,
foi necessário criar um \textit{script} que gerasse o ficheiro de configuração do WireGuard, e que fosse possível enviar esse ficheiro para o dispositivo do utilizador.
%-------------------------------------------------------------------------------------------------
\subsection{Problemas na aplicação Windows/Android}
Durante o desenvolvimento da aplicação, foram encontrados diversos problemas, como por exemplo:
\begin{itemize}
	\item Problemas de compatibilidade entre tipos de base de dados (SQLite e Schemas);
	      \begin{itemize}
		      \item Incompatibilidade de nomes entre tabelas, sendo necessário colocar as tabelas em letra minúscula em ambos;
		      \item Configurações por defeito diferentes entre as plataformas, sendo necessário deixar explícito em ambos os lados 
              sobre as configurações necessárias, como por exemplo "\textit{NOT NULL}";
	      \end{itemize}
	\item Permissões do Android, sendo necessário adicionar todas as permissões necessárias no AndroidManifest.xml para funcionar corretamente;
	\item Visualização/sincronização incorreta das informações e a impossibilidade de modificar a base de dados enquanto a aplicação está a correr, sendo necessário 
	criar bases de dados temporárias para permitir a edição dos dados.
\end{itemize}

%-------------------------------------------------------------------------------------------------
\subsection{Depuração da camada criptográfica e protocolo de \textit{framing}}
\label{subsec:cripto-framing}
    	\textbf{Contexto.} A arquitetura Cliente Android (Kotlin) \(\leftrightarrow\) Servidor PC (Python) exige confidencialidade e integridade ponta-a-ponta. Foi adotado Serpent-256 em modo AEAD, com AAD a autenticar metadados. Em testes iniciais surgiram falhas consistentes de decriptação (\texttt{BAD\_DECRYPT}).

	\textbf{Sintomas observados.}
\begin{itemize}
    \item \texttt{BAD\_DECRYPT} repetido antes de qualquer \textit{plaintext} ser obtido.
    \item Comprimento de chave correto (32 bytes), AAD com 38 bytes constantes mas não padronizados.
    \item Falha idêntica entre várias “abordagens de compatibilidade”, sugerindo desalinhamento estrutural (nonce/tag/AAD) e não corrupção de dados.
    \item Envio rápido de duas mensagens causava paragens no receptor (``silêncio'') ou exceções intermitentes.
\end{itemize}

	\textbf{Metodologia de depuração.}
\begin{enumerate}[label=\alph*)]
    \item Instrumentação com \textit{logs} DEBUG antes/depois de: derivação de chave, montagem de AAD, geração/uso de nonce, chamada AEAD.
    \item \textit{Hexdump}/\textit{base64} lado-a-lado (cliente/servidor) de AAD, nonce, \textit{ciphertext}, tag; assertivas de tamanho de segmentos.
    \item Ensaios com \textit{scripts} Python isolando a decriptação e testes negativos (alteração de 1 byte para confirmar assinatura de falha).
    \item Validações com ferramentas auxiliares (\texttt{openssl dgst}, \texttt{hexdump -C}).
\end{enumerate}

	\textbf{Hipóteses priorizadas.}
\begin{itemize}
    \item Divergência de modo AEAD (GCM/EAX) ou parâmetros.
    \item Nonce/IV com tamanho/ordem diferentes (p. ex., 12 vs 16 bytes) ou reutilização acidental.
    \item Tag truncada (12 vs 16 bytes) na serialização.
    \item Construção de AAD assimétrica (ordem, endianidade, inclusão/omissão de campos).
    \item Parâmetros de KDF distintos (\textit{salt}/\textit{info}).
    \item Fragilidade no \textit{framing}: concatenação de mensagens sem delimitador robusto e leituras parciais do \textit{socket}.
\end{itemize}

	\textbf{Normalização do envelope e \textit{framing}.}
Para eliminar ambiguidades foi definido e documentado um formato binário único, precedido por um \emph{length-prefix} de 4 bytes (\textbf{big-endian}):
\begin{itemize}
    \item \textbf{LEN(4)} | \textbf{MAGIC(2)} | \textbf{VER(1)} | \textbf{ALG(1)} | \textbf{FLAGS(1)} | \textbf{SEQ(8)} | \textbf{TIMESTAMP(8)} | \textbf{NONCE(12)} | \textbf{TAG(16)} | \textbf{AAD\_LEN(2)} | \textbf{CT\_LEN(4)} | \textbf{AAD} | \textbf{CIPHERTEXT}.
    \item \textbf{AAD determinística}: subset autenticado com ordem/endianidade fixas (MAGIC, VER, ALG, FLAGS, SEQ, TIMESTAMP, USER\_ID, RESERVED).
    \item \textbf{NONCE (12 bytes)} derivado de prefixo da chave (4B de SHA-256(key)) concatenado com \textbf{SEQ} (8B big-endian) $\rightarrow$ unicidade garantida por mensagem.
    \item \textbf{TAG} fixo de 16 bytes, sem truncagem.
\end{itemize}

	\textbf{Implementações e salvaguardas.}
\begin{itemize}
    \item \textit{BufferAssembler} do lado PC: acumula \textbf{LEN} e corpo até \textit{frame} completo antes de decifrar, evitando leitura parcial ou colagem de mensagens.
    \item \textbf{SEQ} monotónico incluído no AAD e usado na derivação do NONCE para prevenir reutilização e facilitar rastreabilidade.
    \item \textbf{Self-test vector} no arranque: cifra/decifra um vetor conhecido e aborta se falhar, evitando sessões inválidas.
    \item \textit{Backpressure}/ACK opcional: segunda mensagem só após ACK da primeira em fases de diagnóstico.
    \item \textbf{Logs estruturados}: dump de \texttt{hex(AAD|NONCE|TAG)} e comprimentos; contadores de \texttt{AEAD\_FAIL} separados de exceções gerais.
\end{itemize}

	extbf{Bug das duas mensagens consecutivas.}
\begin{itemize}
    \item Causa raiz: \textit{framing} frágil (concatenação sem delimitador) e processamento sem acumulador de \textit{frames}.
    \item Mitigações: \textit{length-prefix} + \textit{BufferAssembler}; não reutilizar (key, nonce); captura e tratamento de exceções sem encerrar o ciclo de leitura.
\end{itemize}

	\textbf{Resultados e validação.}
\begin{itemize}
    \item Eliminação do ``silêncio'' após ráfagas curtas e ausência de \texttt{BAD\_DECRYPT} nas execuções instrumentadas.
    \item \textit{Stress tests} internos com pares de mensagens (intervalos 30--250 ms) sem \textit{crash}; \textit{logs} confirmam \textbf{SEQ} crescente e \textit{frames} completos.
    \item Critérios de fecho definidos: 0 ocorrências \texttt{BAD\_DECRYPT} em campanhas prolongadas; 100 envios duplos consecutivos sem \textit{crash}; latência média $< 150$ ms; \textbf{SEQ} sem desvios não explicados.
\end{itemize}

	\textbf{Lista de verificação (antes de nova tentativa).}
\begin{itemize}
    \item Mesmo algoritmo e modo AEAD nos dois lados; \textbf{TAG=16B}, \textbf{NONCE=12B} único.
    \item KDF com \textit{salt}/\textit{info} idênticos; AAD determinística e documentada.
    \item \textit{Framing} com \textbf{LEN(4)} ativo; tratamento de exceções não encerra o processo.
    \item \textbf{Self-test} no arranque aprovado.
\end{itemize}

	\textbf{Lições aprendidas.} A principal fonte de instabilidade não era apenas a cifra, mas a ausência de um contrato binário formal (layout de envelope + AAD + \textit{framing}). Ao fixar cada campo e a sua semântica, reduziram-se incompatibilidades e simplificou-se a depuração. A unicidade do nonce derivado de \textbf{SEQ} e a instrumentação detalhada foram determinantes para estabilizar o sistema.

\medskip
\textbf{Fundamentação teórica (AEAD, AAD, nonces e framing).}
\begin{itemize}
    \item \textbf{AEAD} (\textit{Authenticated Encryption with Associated Data}) combina confidencialidade e integridade: a decriptação falha integralmente se qualquer bit do \textit{ciphertext}, da \textbf{TAG} ou da \textbf{AAD} estiver alterado. Isto previne ataques de manipulação e “corta e cola”.
    \item \textbf{AAD} é não cifrada mas autenticada; deve incluir metadados que definem o contexto (p. ex., versão, algoritmo, \textbf{SEQ}, \textbf{USER\_ID}). Divergências entre emissor e recetor provocam \texttt{BAD\_DECRYPT} por falha na verificação da TAG.
    \item O tamanho da \textbf{TAG} (tipicamente 16 bytes) é um compromisso entre segurança e espaço. Truncagens elevam o risco de falsificações bem-sucedidas.
    \item \textbf{Nonces/IVs} em modos como GCM/EAX devem ser \emph{únicos por chave}. Reutilização de nonce compromete a confidencialidade e pode afetar a integridade.
\end{itemize}

\textbf{Modos AEAD e requisitos de nonce.}
\begin{itemize}
    \item \textbf{GCM}: desempenho elevado; nonce recomendado de 96 bits (12 bytes) e unicidade estrita por chave.
    \item \textbf{EAX/OCB}: alternativas com requisitos semelhantes de unicidade. OCB teve restrições de patente históricas.
    \item \textbf{SIV} (\textit{Synthetic IV}): tolera reutilização de nonce, adequado quando a unicidade não é garantida, à custa de desempenho.
    \item \textbf{Prática adotada}: NONCE = prefixo derivado da chave || \textbf{SEQ} (12 bytes), garantindo unicidade se \textbf{SEQ} for monotónico por sessão.
\end{itemize}

\textbf{Derivação e separação de chaves (KDF).}
\begin{itemize}
    \item Utilize \textbf{HKDF} com \textit{salt} e \textit{info} para derivar chaves de sessão a partir de uma raiz, aplicando \emph{domain separation} para \textit{encrypt}, \textit{mac}, \textit{nonce-prefix}, etc.
    \item Evite reutilizar a mesma chave para múltiplos propósitos; separe por função para reduzir o acoplamento e facilitar auditoria.
    \item Considere rotação por tempo ou contagem; registe \textbf{VER}/\textbf{ALG} no envelope para agilidade criptográfica.
\end{itemize}

\textbf{Framing em canais de \textit{byte-stream} (TCP).}
\begin{itemize}
    \item TCP pode fragmentar ou coalescer envios; o recetor deve reconstituir \textit{frames} completos.
    \item Um \textbf{length-prefix} fixo (4 bytes big-endian) torna os \textit{frames} auto-delimitados e evita ambiguidades.
    \item Defina \textbf{limites máximos} por \textit{frame} e valide \textbf{LEN} antes de alocar/copiar; implemente um \textit{BufferAssembler} que apenas decifra após \textit{frame} completo.
\end{itemize}

\textbf{Proteções adicionais.}
\begin{itemize}
    \item \textbf{SEQ} monotónico, janela anti-\textit{replay} e \textbf{TIMESTAMP} para diagnóstico e controlo de ritmo.
    \item Comparação de \textbf{TAG} em tempo constante; limpeza de chaves e \textit{buffers} sensíveis quando possível.
    \item Erros genéricos no protocolo e \textit{logs} internos detalhados com limitação de taxa.
\end{itemize}

\textbf{Testes e verificação.}
\begin{itemize}
    \item \textbf{Vetores de teste} determinísticos no arranque (\textit{self-test}).
    \item \textbf{Fuzzing} do \textit{BufferAssembler} e do desserializador; testes de propriedades (\textit{round-trip}, rejeição a \textit{bitflips}).
    \item Testes negativos: nonce repetido, TAG truncada, AAD alterada; \textbf{stress tests} com ráfagas e latências variáveis.
\end{itemize}
% ...existing code...
\newpage
% ...existing code...
\section{Testes}\label{testes}
Os testes realizados tem como base 2 metodos:
\begin{itemize}
	\item Verificação da base de dados através do servidor
	\item Sniffing das comunicações com o uso do Wireshark
\end{itemize}
%-------------------------------------------------------------------------------------------------
\subsection{Servidor}
Os testes realizados no servidor foram focados na verificação da base de dados e na monitorização das comunicações.
Para a verificação da base de dados, é feita a tentativa de ler o ficheiro enviado, e como é possivel verificar nas figuras abaixo,
ao ler o ficheiro sem criptografia, é possível visualizar o seu conteúdo perfeitamente, ao ler o ficheiro com criptografia,
não é possível visualizar o seu conteúdo pois o servidor guarda a base de dados sem desencriptar, isto leva a que o ficheiro nem seja reconhecido como uma base de dados.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{Recursos/DBNormal.png}
        \caption{Sem Criptografia}
        \label{fig:db_normal}
    \end{subfigure}
    \vskip 2cm
    \begin{subfigure}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{Recursos/DBEncriptada.png}
        \caption{Com Criptografia}
        \label{fig:db_encriptada}
    \end{subfigure}
    \caption{Teste com Servidor}
    \label{fig:wireshark_msg_duas_imagens}
\end{figure}
\newpage
%-------------------------------------------------------------------------------------------------   
\subsection{Comunicações}
Para a monitorização das comunicações, foi utilizado o Wireshark para fazer sniffing dos pacotes que estavam a ser enviados e recebidos pelo servidor.
Como é possivel ver nas figuras abaixo, estes são os resultados:

\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{1.05\textwidth}
        \includegraphics[width=\textwidth]{Recursos/WiresharkNormalMSG.png}
        \caption{Sem Criptografia}
        \label{fig:wireshark_normal_fora}
    \end{subfigure}

    % Espaço vertical entre as imagens
    \vskip 1cm

    \begin{subfigure}[b]{1.05\textwidth}
        \includegraphics[width=\textwidth]{Recursos/WiresharkEncriptadaMSG.png}
        \caption{Com Criptografia}
        \label{fig:wireshark_encriptado_fora}
    \end{subfigure}
    \caption{Teste com Servidor}
    \label{fig:duas_imagens}
\end{figure}
Para obter esta captura, foi necessário selecionar dentro do Wireshark o adaptador associado à VPN para ver o tráfego que passa lá dentro. Ao analisar o resultado obtido pelo
Wireshark não é possível detetar nenhuma diferença óbvia, sem ser a questão do aparecimento do \textit{(text/html)} nas mensagens criptografadas. 
Isto, só se vai tornar mais visível, quando for selecionada a mensagem, e com o botão direito do rato, selecionar depois a opção \textit{Follow --> TCP Stream},
isto fará com que apareçam os resultados das figuras \ref{fig:wireguard_normal} e \ref{fig:wireguard_encriptado}.

\newpage
Sendo assim, podemos analisar o conteúdo desta mensagem 
HTTP, sendo ele na figura \ref{fig:wireguard_normal} a estrutura da base de dados nas fases iniciais do projeto, onde ainda não estava criptografada. Ao analisar o conteúdo após,
seria possível visualizar todas as informações da base de dados, incluindo utilizadores, mensagens e outros dados sensíveis.
\begin{figure}[h]
        \centering
        \includegraphics[width=0.7\textwidth]{Recursos/WiresharkNormal.png}
        \caption{Wireshark Sem Criptografia}
        \label{fig:wireguard_normal}
\end{figure}
\newpage
Agora, ao analisar o conteúdo da figura \ref{fig:wireguard_encriptado}, podemos ver que a estrutura da base de dados está ilegível para um
ser humano devido à criptografia AES256/Serpent, sendo impossível saber o conteúdo se não for feita a decriptação, e para isto ocorrer 
é necessário ter acesso à chave, seja para "desenvolopar", seja para desencriptar. Isto garante a segurança 
das comunicações caso o acesso à VPN seja comprometido, e uma pessoa não autorizada consiga aceder ao tráfego que passa pela VPN.
\begin{figure}[h]
    \centering
        \includegraphics[width=0.7\textwidth]{Recursos/WiresharkEncriptada.png}
        \caption{Wireshark Com Criptografia}
        \label{fig:wireguard_encriptado}
\end{figure}


%---------------------------------------------------------------------------------------------------------------------------
\section{Melhorias Futuras}
Este projeto está sujeito a imensas melhorias, tais como:
\begin{itemize}
    \item Implementação de novas funcionalidades, como mensagens de voz/chamadas criptografadas;
    \item Melhoria da interface do utilizador;
    \item Aumento da segurança das comunicações, adicionando HTTPS em vez de HTTP.
\end{itemize}
%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Conclusão}\label{con}
Concluimos assim que o projeto foi um sucesso, pois conseguimos desenvolver um sistema de comunicações seguras
que permite a troca de mensagens de texto entre os seus utilizadores, sem que haja a possibilidade de terceiros acederem às mensagens trocadas.
Em geral, foi um projeto que nos permitiu aprender bastante sobre a área de cibersegurança e comunicações seguras,
e que nos possibilitou aplicar os conhecimentos adquiridos ao longo do curso de Engenharia Informática.
%---------------------------------------------------------------------------------------------------------------------------

\newpage
\renewcommand{\refname}{Bibliografia} % Para artigos
\renewcommand{\bibname}{Bibliografia} % Para livros e relatórios
\addcontentsline{toc}{section}{Bibliografia} % Adiciona a Bibliografia ao índice
\printbibliography
\newpage
\end{document}
