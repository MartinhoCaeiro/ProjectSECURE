\documentclass[a4paper]{article}
\usepackage[portuguese]{babel}
\usepackage[backend=biber, style=apa, citestyle=apa, language=portuguese]{biblatex}
\usepackage{csquotes}
\addbibresource{Recursos/referencias.bib}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{setspace}
\usepackage{siunitx} % Required for alignment
\sisetup{
  round-mode          = places, % Rounds numbers
  round-precision     = 2, % to 2 places
}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{karnaugh-map}
\usepackage[section]{placeins}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{titling}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{xcolor}
\usepackage{indentfirst}
\usepackage{array}
\usepackage{wrapfig} % Coloca isto no preâmbulo
\usepackage{soul}
\usepackage{afterpage}
\usepackage[toc,page]{appendix}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
% Código: listings para incluir trechos de código no relatório
\usepackage{listings}
\usepackage{courier}
\lstdefinelanguage{Kotlin}{
    keywords={package,import,object,fun,val,var,private,const,if,else,return,require,when,as,is},
    morekeywords={ByteArray,SecureRandom,Cipher,GCMParameterSpec,SecretKeySpec,AEADParameters,PKCS5S2ParametersGenerator,SHA256Digest},
    sensitive=true,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    string=[b]"
}
\lstset{
    language=Kotlin,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray},
    stringstyle=\color{orange},
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    captionpos=b
}


% Comando para criar uma página vazia
\newcommand\myemptypage{
    \null
    \thispagestyle{empty}
    \addtocounter{page}{-1}
    \newpage
}

% Página de título principal
\newcommand{\firsttitlepage}{
    \begin{titlepage}
        \centering
        
        % Logos superior
        \begin{figure}[h!]
            \centering
            \includegraphics[width=6cm]{Recursos/Logos/LOGO_IPB} % Substitua pelo caminho da imagem
            \vspace{0.5cm}
        \end{figure}    
        % Informações da instituição
        \large\textbf{INSTITUTO POLITÉCNICO DE BEJA} \\
        \large\textbf{Escola Superior de Tecnologia e Gestão} \\
        \large\textbf{Licenciatura em Engenharia Informática} \\
        \large\textbf{Projeto Final de Curso} \\
        
        
        % Título do projeto
        {\Huge \textbf{Desenvolvimento de um sistema de comunicações seguras }} \\
        
        \vspace{1cm}
        
        % Autores
    
        \large Martinho José Novo Caeiro - 23917 \\
        \large Paulo António Tavares Abade - 23919 \\
        \large Rafael Conceição Narciso - 24473 \\
        
        \vfill
        
        % Logo inferior
        \begin{figure}[h!]
            \centering
            \includegraphics[width=6cm]{Recursos/Logos/IPBejaESTIG.jpg} % Substitua pelo caminho da imagem
        \end{figure}
        
        % Local e data
        {\large Beja, setembro de 2025}
    \end{titlepage}
}

\newcommand{\secondtitlepage}{
    \begin{titlepage}
        \centering
        \vspace*{1cm}
        
        % Informações da instituição
        \large\textbf{INSTITUTO POLITÉCNICO DE BEJA} \\
        \large\textbf{Escola Superior de Tecnologia e Gestão} \\
        \large\textbf{Licenciatura em Engenharia Informática} \\
        \large\textbf{Projeto Final de Curso} \\
        
        \vspace{2cm}
        
        % Título do projeto
        {\Huge \textbf{Desenvolvimento de um sistema de comunicações seguras }} \\
        
        \vspace{1.5cm}
        
        % Autores
        \large Martinho José Novo Caeiro - 23917 \\
        \large Paulo António Tavares Abade - 23919 \\
        \large Rafael Conceição Narciso - 24473 \\

        \vspace{2cm}

        % Orientador
        \large Orientador: Professor Rui Silva \\
        
        \vfill
        
        % Local e data
        {\large Beja, setembro de 2025}
    \end{titlepage}
}

\begin{document}


\pagenumbering{gobble} % Oculta numeração da página

% Primeira página de título
\firsttitlepage

\secondtitlepage


% Abstract
\section*{\LARGE\textbf{\textit{Resumo}}}

Neste relatório será abordado o processo de criação de uma solução de comunicações seguras,
que permita a troca de mensagens de texto entre os seus utilizadores.
Este relatório foi realizado no âmbito da Unidade Curricular de
Estágio ou Projeto (\cite{pagep}).


\vspace{1cm}
% Keywords
\textbf{Keywords:} aplicações, cibersegurança, comunicações, criptografia, c\#, python, bash, almalinux, wireguard, sqlite, kotlin
\newpage
%--------------------------------------------------------------------------------------------------------------------------------------

\section*{\LARGE\textbf{\textit{Abstract}}}

In this report, we will address the creation process of a secure communication
solution that allows text message exchange between its users.
This report was carried out within the scope of the
Curricular Unit of Internship or Project (\cite{pagep}).


\vspace{1cm}
% Keywords
\textbf{Keywords:} applications, cybersecurity, communications, cryptography, c\#, python, bash, almalinux, wireguard, sqlite, kotlin
\renewcommand{\contentsname}{Índice}       % Título do sumário
\renewcommand{\listfigurename}{Índice de Figuras} % Título da lista de figuras

% Início do conteúdo do relatório
\newpage
\doublespacing
\tableofcontents
\newpage
\listoffigures
\doublespacing

\newpage
\pagenumbering{arabic}

\section{Introdução}\label{intro}
Para a realização do projeto é necessário desenvolver um sistema de comunicações seguras, que permita a troca de mensagens de texto entre os seus utilizadores.
Para tal, é necessário implementar um sistema de autenticação de utilizadores, que permita a criação de contas de utilizador e a autenticação dos mesmos.
O sistema deve ser capaz de garantir a confidencialidade, integridade e autenticidade das mensagens trocadas entre os utilizadores. As tecnologias a utilizadas
no desenvolvimento deste projeto são: WireGuard (\cite{wireguard}), SQLite (\cite{sqlite}), C\# (\cite{csharp}), Kotlin (\cite{kotlin}), Python (\cite{python}),
Bash (\cite{bash}), AlmaOS (\cite{almaos}). Em relação a criptografia, serão utilizados os algoritmos Rijndael (vencedor do AES) e
Serpent (segundo lugar do AES), que são algoritmos de criptografia simétrica.

Para este projeto, foi decidido utilizar uma variação da metodologia do \textit{SCRUM}, onde eram realizadas reuniões semanais ao ínicio, e depois
foi sendo feito para ocorrer mais tempo entre reuniões, de forma a que fosse possível ter mais tempo para o desenvolvimento das
tarefas. Os três membros da equipa foram divididos entre as três áreas do projeto, nomeadamente: desenvolvimento da aplicação Windows,
desenvolvimento da aplicação Android e por último, a configuração da infraestrutura da rede.

O cronograma do projeto foi dividido em duas fases principais: Análise de Requisitos, Desenvolvimento, como é possível
ver na figura \ref{fig:project_schedule}. O relatório foi modificado a cada semana, acrescentando novas informações e
atualizações sobre o progresso do projeto.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/Cronograma.png}
	\caption{Cronograma do Projeto}
	\label{fig:project_schedule}
\end{figure}

Este projeto ficou guardado nos repositórios do GitHub da equipa, onde pode ser consultado por outros alunos e professores, a partir do seguinte
link:\\ \url{https://github.com/MartinhoCaeiro/Projeto-Cripto} \&  \url{https://github.com/NarcisoUNK/ProjectFinal_ANDROID}.
%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Analise de Requisitos}\label{analise}
Para a realização deste projeto, foram necessários os seguintes requisitos:
\begin{itemize}
	\item \textbf{Requisitos Funcionais:}
	      \begin{itemize}
		      \item O sistema deve permitir a criação de contas de utilizador.
		      \item O sistema deve permitir a autenticação de utilizadores.
		      \item O sistema deve permitir o envio e receção de mensagens entre utilizadores.
		      \item O sistema deve garantir a confidencialidade, integridade e autenticidade das mensagens trocadas.
	      \end{itemize}
	\item \textbf{Requisitos Não Funcionais:}
	      \begin{itemize}
		      \item O sistema deve ser seguro e resistente a ataques.
		      \item O sistema deve ser fácil de usar e intuitivo.
		      \item O sistema deve ser escalável e capaz de suportar um grande número de utilizadores.
	      \end{itemize}
\end{itemize}

Foram ainda analisadas outras aplicações de troca de mensagens seguras, como o \textit{WhatsApp} (\cite{whatsapp}) 
e \textit{Telegram} (\cite{telegram}), para compreender como estas funcionam. Chegando à conclusão de que utilizam
uma encriptação de ponta a ponta para garantir a segurança das mensagens. Neste projeto, será implementada uma abordagem 
bastante semelhante, porém com a integração da VPN.

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Tecnologias Utilizadas}\label{tecnologias}
Para o desenvolvimento deste projeto, foram utilizadas as seguintes tecnologias:
\begin{itemize}
	\item \textbf{Linguagens de Programação:} C\#, Kotlin
	\item \textbf{Frameworks:} .NET, WireGuard
	\item \textbf{Base de Dados:} SQLite
	\item \textbf{Criptografia:} Rijndael (Vencedor AES), Serpent (Segundo lugar AES)
	\item \textbf{Ferramentas de Desenvolvimento:} Git, Visual Studio Code, Android Studio
	\item  \textbf{Serviços de Hospedagem:} GitHub
\end{itemize}

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Arquitetura do Sistema}\label{arquitetura}
O sistema é composto por uma aplicação que funcionará como um chat, onde os utilizadores que estiverem registado na VPN poderão comunicar entre si.
Dentro da aplicação, os utilizadores podem saber quem está associado a um endereço IP da VPN, e assim enviar mensagens para esse utilizador.
Ao enviar uma mensagem, a aplicação irá contatar o servidor da VPN, para obter o caminho até ao destinatário, e assim enviar a mensagem.
Essa mensagem será encriptada antes de ser enviada, para garantir a confidencialidade e integridade da mensagem. Existe a variação
da encriptação utilizada na mensagem, de acordo com uma lógica pré-definida na aplicação, sendo que os métodos de encriptação utilizados são o AES
e o Serpent.
\subsection{Encriptação do Sistema}
Sendo assim, a parte de encriptação das mensagens será feita como está demonstrado na figura \ref{fig:encryption_process}. A mensagem
será encriptada consoante um número pseudo-aleatório gerado pela aplicação, sendo assim escolhido o algoritmo de encriptação a utilizar naquele momento, o AES256 ou Serpent.
Para encriptar, é necessário fornecer também uma chave de encriptação. Nesta fase, a chave de encriptação é "\textit{\textbf{Spartacus}}". É importante destacar que o seletor 
está ofuscado, de forma a dificultar a sua identificação, a partir de uma máscara criada através da chave (\textit{salt}) e do número pseudo-aleatório.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/Encripta.png}
	\caption{Processo de Encriptação das Mensagens}
	\label{fig:encryption_process}
\end{figure}

\newpage

Para desencriptar, é necessário fazer o processo inverso. Desta forma, o número pseudo-aleatório está anexado à mensagem encriptada,
permitindo assim descobrir qual o algoritmo de encriptação utilizado. É possível ver este processo na figura \ref{fig:decryption_process}.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/Decripta.png}
	\caption{Processo de Decriptação das Mensagens}
	\label{fig:decryption_process}
\end{figure}

\subsection{Estrutura do Sistema}
A estrutura do sistema é focada na troca de informação por dentro da VPN, podendo ser representada 
na seguinte figura \ref{fig:system_architecture}: 
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Recursos/SistemaFisico.png}
    \caption{Arquitetura do Sistema}
    \label{fig:system_architecture}
\end{figure}
%---------------------------------------------------------------------------------------------------------------------------

\subsection{Implementação da Criptografia (excerto)}

O projecto inclui um módulo chamado \texttt{DbCrypto} (implementado em Kotlin/Java) responsável por encapsular a encriptação e desencriptação dos conteúdos armazenados.
Segue-se um excerto explicativo com os pontos-chave e um trecho do código mais relevante.

\paragraph{Resumo da lógica}
\begin{itemize}
  \item Gera-se um \textbf{salt} e um \textbf{nonce} aleatórios para cada encriptação.
  \item Deriva-se uma chave simétrica (256 bits) a partir da passphrase/\textit{masterKey} usando PBKDF2-SHA256 (100k iterações).
  \item Calcula-se uma máscara (\textit{mask}) para ofuscar qual o algoritmo usado (AES ou Serpent) e guarda-se o valor ofuscado no cabeçalho.
  \item Usa-se AES-GCM ou Serpent-GCM (via BouncyCastle) com AAD contendo o cabeçalho (magic, versão, algoritmo-ofuscado, iterações, salt e nonce).
  \item O ficheiro resultante é: cabeçalho || ciphertext || tag.
\end{itemize}

\paragraph{Trecho de código}
\begin{lstlisting}[caption={Excerto de \texttt{DbCrypto} — função de encriptação}]
private fun encryptInternal(data: ByteArray, masterKey: ByteArray, salt: ByteArray, nonce: ByteArray, alg: Alg): ByteArray {
    val key = deriveKey(masterKey, salt, ITERATIONS)
    val mask = computeAlgMask(masterKey, salt)
    val algXor = (alg.code.toInt() xor (mask.toInt() and 0xFF)).toByte()
    val aad = buildHeader(algXor, ITERATIONS, salt, nonce) // full header is AAD
    val ctWithTag = if (alg == Alg.AES) {
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, "AES"), GCMParameterSpec(TAG_SIZE * 8, nonce))
        cipher.updateAAD(aad)
        cipher.doFinal(data)
    } else {
        val gcm = GCMBlockCipher(SerpentEngine())
        gcm.init(true, AEADParameters(KeyParameter(key), TAG_SIZE * 8, nonce, aad))
        val out = ByteArray(gcm.getOutputSize(data.size))
        var len = gcm.processBytes(data, 0, data.size, out, 0)
        len += gcm.doFinal(out, len)
        out.copyOf(len)
    }
    return envelope(algXor, salt, nonce, ctWithTag)
}
\end{lstlisting}

\paragraph{Preview / Exemplo de validação}
Para validar o comportamento foi utilizada a função de desencriptação que verifica o cabeçalho, desfaz a máscara do algoritmo,
re-deriva a chave com os mesmos parâmetros e tenta a desencriptação; a produção correcta deverá retornar o conteúdo SQLite original (verifica-se o "magic" do SQLite).


\section{Módulos do Sistema}\label{modulos}

\subsection{Interface do Sistema}
A interface para computador será desenvolvida em C\#, cuja qual é uma linguagem rápida e fácil de aprender, e que permite o desenvolvimento de aplicações desktop de forma rápida e eficiente, enquanto 
que a interface para Android será desenvolvida em Kotlin, que é uma linguagem de programação moderna e concisa, que permite o desenvolvimento de aplicações Android de forma rápida e eficiente.
Esta interface é composta por 4 ecrãs principais:
\begin{itemize}
	\item \textbf{Ecrã de Login:} onde o utilizador pode autenticar-se na aplicação utilizando as suas credenciais, tambem é possivel ver o status da ligação WireGuard.
	\item \textbf{Ecrã de Lista de Chats:} onde o utilizador pode ver a lista de chats existentes, bem como criar novos chats.
	\item \textbf{Ecrã de Chat:} onde o utilizador pode enviar e receber mensagens de outros utilizadores.
	\item \textbf{Ecrã de Configuração WireGuard:} onde o utilizador pode criar um ficheiro para configuração do WireGuard.
\end{itemize}

\subsection{Módulo da VPN}
A VPN estará alojada num servidor com o sistema operativo AlmaOS 8.10 (\cite{almaos}), e será responsável por gerir as ligações dos utilizadores à VPN,
bem como a autenticação dos mesmos. O serviço escolhido foi o WireGuard, que é um serviço de VPN de código aberto,
leve e de alto desempenho, que utiliza criptografia moderna para garantir a segurança das comunicações. É necessário configurar previamente o WireGuard no dispositivo
do utilizador, para que este possa estabelecer uma ligação à VPN.


\newpage 
\subsection{Base de Dados}
A base de dados será utilizada para armazenar as informações dos utilizadores, como as suas credenciais, bem como as mensagens trocadas entre os utilizadores, esta será implementada utilizando o SQLite.
A base de dados irá ter a seguinte estrutura:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/ProjectSecure_DB.png}
	\caption{Estrutura da Base de Dados}
	\label{fig:db_structure}
\end{figure}

\newpage 

Sendo que a base de dados é composta por 4 tabelas, cada uma com as suas respetivas colunas,
sendo que as tabelas são:

\begin{minipage}{\textwidth}


    \begin{itemize}

        \item \textbf{User:}
              \begin{itemize}
                  \item UserID (chave primária)
                  \item Username (string)
                  \item Password (string)
              \end{itemize}

        \item \textbf{Chat:}
              \begin{itemize}
                  \item ChatID (chave primária)
                  \item Name (string)
                  \item AdminID (chave estrangeira, referência à tabela User)
              \end{itemize}

        \item \textbf{Participant:}
              \begin{itemize}
                  \item ParticipantID (chave primária)
                  \item ChatID (chave estrangeira, referência à tabela Chat)
                  \item UserID (chave estrangeira, referência à tabela User)
              \end{itemize}
              \newpage
        \item \textbf{Message:}
              \begin{itemize}
                  \item MessageID (chave primária)
                  \item ParticipantID (chave estrangeira, referência à tabela Participant)
                  \item Content (string)
                  \item Date (data e hora da mensagem)
                  \item SenderUserID (chave estrangeira, referência à tabela Participant)
              \end{itemize}
    \end{itemize}


\end{minipage}

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Desenvolvimento}\label{desenvolvimento}
\subsection{Interface para Computador}
Para o desenvolvimento da interface para computador, foi utilizado o Visual Studio Code, que é um ambiente de desenvolvimento integrado (IDE) da Microsoft.

\subsubsection{Ecrã de Login}
O ecrã de login é composto por um formulário onde o utilizador pode inserir as suas credenciais, e um botão para autenticar-se na aplicação.
Caso não tenha uma conta criada apenas tem que preencher o formulario e clicar no botão de criar conta, esta ação só é possivel com o Wireguard ativado.
Também é possivel ver o estado da ligação WireGuard, caso esteja ligado ou desligado.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/LoginPC1.png}
        \caption{WireGuard Ativado}
    \label{fig:login_pc_img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/LoginPC2.png}
        \caption{Wireguard Desativado}
    \label{fig:login_pc_img2}
    \end{subfigure}
    \caption{Ecrã de Login - Computador}
    \label{fig:login_pc_duas_imagens}
\end{figure}

\newpage
\subsubsection{Ecrã de Lista de Chats}
O ecrã de lista de chats é composto por uma lista de chats existentes e um botão para criar novos chats, este só pode ser criado com o WireGuard ativado.
No seu canto superior direito, existe um botão para aceder às definições da aplicação, onde o utilizador pode configurar se quer a aplicação em modo escuro ou claro,
e no seu canto inferior esquerdo existe um botão para terminar sessão caso deseja mudar de utilizador.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ListaPC1.png}
        \caption{WireGuard Ativado}
    \label{fig:lista_pc_img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ListaPC2.png}
        \caption{Wireguard Desativado}
    \label{fig:lista_pc_img2}
    \end{subfigure}
    \caption{Ecrã de Lista de Chats - Computador}
    \label{fig:lista_pc_duas_imagens}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Chat}
O ecrã de chat é composto por uma lista de mensagens trocadas entre os utilizadores, mensagens recebidas ficam do lado esquerdo e mensagens enviadas no lado direito.
Apenas é possivel enviar mensagens com o WireGuard ativado, para enviar uma mensagem basta escrever no campo de texto e clicar no botão de enviar.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ChatPC1.png}
        \caption{WireGuard Ativado}
    \label{fig:chat_pc_img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ChatPC2.png}
        \caption{Wireguard Desativado}
    \label{fig:chat_pc_img2}
    \end{subfigure}
    \caption{Ecrã de Chat - Computador}
    \label{fig:chat_pc_duas_imagens}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Configuração WireGuard}
O ecrã de configuração WireGuard é composto por um formulário onde o utilizador insere o seu nome, e um botão para descarregar o ficheiro de configuração do WireGuard.
\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{Recursos/WireguardPC.png} % Substitua pelo caminho da imagem
	\label{fig:wireguard_pc}
	\caption{Ecrã de Configuração WireGuard - Computador}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsection{Interface para Android}
Para o desenvolvimento da interface para Android, foi utilizado o Android Studio, que é um ambiente de desenvolvimento integrado 
(IDE) oficial para o sistema operativo Android.
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Login}
O ecrã de login é composto por um formulário onde o utilizador pode inserir as suas credenciais, e um botão para autenticar-se na aplicação. 
Este pode iniciar sessão ou criar uma conta, caso não possua uma. Também é possivel ver o estado da ligação WireGuard, caso esteja ligado 
ou desligado. Existe ainda a possibilidade de estabelecer a comunicação de uma forma mais prática para o utilizador, através do download do 
ficheiro de configuração do WireGuard.

\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/LoginAndroid.png} % Substitua pelo caminho da imagem
    \label{fig:android_login}
    \caption{Ecrã de Login - Android}
    
\end{figure}
\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de configuração do WireGuard}
Neste ecrã, o utilizador pode inserir um nome que está associado à sua ligação WireGuard. Após inserir e enviar o pedido, será 
fornecido o ficheiro de configuração do WireGuard, que pode ser importado diretamente na aplicação do WireGuard no dispositivo Android.

\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/WireguardAndroid.png} % Substitua pelo caminho da imagem
    \label{fig:android_config_wireguard}
    \caption{Ecrã de Configuração do WireGuard - Android}
    
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Lista de Chats}
O ecrã de lista de chats é composto por uma lista de conversas anteriores, onde o utilizador pode selecionar uma conversa para visualizar o seu conteúdo. 
Neste ecrã, também é possível iniciar uma nova conversa, caso o utilizador deseje.
\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/ListaAndroid.png} % Substitua pelo caminho da imagem
    \caption{Lista de Chats - Android}
    \label{fig:android_lista_chats}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Chat}
O ecrã de chat é composto por uma lista de mensagens trocadas entre os utilizadores, mensagens recebidas ficam do lado esquerdo e mensagens enviadas no lado direito.
Apenas é possivel enviar mensagens com o WireGuard ativado, para enviar uma mensagem basta escrever no campo de texto e clicar no botão de enviar.
\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/ChatAndroid.png} % Substitua pelo caminho da imagem
    \caption{Ecrã de Chat - Android}
    \label{fig:android_chat}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsection{AlmaOS - Serviço de VPN}
Para configurar corretamente o serviço de VPN, é necessário instalar o WireGuard no servidor AlmaOS 8.10,
para isso ser feito, foi necessário seguir os seguintes passos:
\begin{enumerate}
	\item Adicionar o repositório EPEL - sudo dnf install epel-release
	\item Adicionar o repositório ELREPO - sudo dnf install https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm
	\item Ativar o CodeReady Builder - sudo /usr/bin/crb enable
	\item Atualizar os metadados - sudo dnf makecache
	\item sudo dnf --enablerepo=elrepo install kmod-wireguard -y
	\item Instalar o WireGuardTools - sudo dnf install wireguard-tools -y
\end{enumerate}
Para verificar se o WireGuard está instalado corretamente, pode-se utilizar o comando \textbf{"sudo modprobe wireguard"},
se este não devolver nenhum output, significa que o WireGuard está instalado corretamente.

Agora, para configurar o WireGuard, é necessário criar as chaves de criptografia, para isso é necessário
ir para a pasta \textbf{/etc/wireguard} e executar o seguintes comando:
\begin{verbatim}
    wg genkey | tee server_private.key | wg pubkey > server_public.key
    chmod 600 server_private.key
\end{verbatim}
Isto irá gerar duas chaves, uma privada e uma pública, que serão utilizadas para autenticar os utilizadores na VPN.
\newpage
Após isso, é necessário criar o ficheiro de configuração do WireGuard, onde estará definida a configuração da VPN em si,
como o endereço IP da VPN, a porta de escuta, as chaves de criptografia, entre outros.
Para isso, é necessário criar o ficheiro \textbf{wg0.conf} na pasta \textbf{/etc/wireguard}, e adicionar o seguinte conteúdo:
\begin{verbatim}
    [Interface]
    PrivateKey = <Chave Privada do Servidor>
    Address = 10.0.0.1/24
    ListenPort = 51820
    SaveConfig = true
    [Peer]
    PublicKey = <Chave Pública do Cliente>
    AllowedIPs = 10.0.0.2/32
\end{verbatim}

Para garantir o bom funcionamento da VPN, é necessário ativar o encaminhamento de endereços IP, para assim permitir o tráfego de rede.
Para isso, é necessário fazer o seguinte comando:
\begin{verbatim}
    # Para permitir o tráfego de rede 
    echo "net.ipv4.ip_forward = 1" | sudo tee -a /etc/sysctl.conf
    sudo sysctl -p

    # Para permitir o tráfego pela porta 51820
    sudo firewall-cmd --add-masquerade --permanent
    sudo firewall-cmd --add-port=51820/udp --permanent
    sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o enp0s3 -j MASQUERADE
    sudo firewall-cmd --reload

\end{verbatim}
\newpage
Para ser possível encaminhar o tráfego de rede, é necessário adicionar uma regra ao Router para que, todos os pacotes que cheguem à porta 51820
sejam encaminhados para o servidor WireGuard.
Por fim, basta iniciar o serviço do WireGuard, para isso é necessário executar o seguinte comando:
\begin{verbatim}
    sudo systemctl enable --now wg-quick@wg0
\end{verbatim}

Para conseguir estabelecer a troca de ficheiros entre o servidor e o cliente, foi necessário implementar
um \textit{script} que gerencia as trocas de ficheiros da base de dados entre os clientes e o servidor.
Esse script foi feito em Python, utiliza a biblioteca Flask para criar uma API REST que permite a comunicação entre o cliente e o servidor.
Foi necessário permitir a porta 8000 no servidor, para que o cliente possa comunicar com o servidor.


Do lado do cada cliente, vai ser necessário configurar o WireGuard, de maneira a que apenas a informação
proveniente da aplicação desenvolvida seja enviada através da VPN, onde assim serão poupados recursos
do dispositivo que está a fazer o papel de servidor. Para isso, foi criado um \textit{script} que cria o ficheiro
de configuração do WireGuard para o cliente, sendo que este só deve adicionar o ficheiro de configuração na aplicação
do WireGuard. O \textit{script} ainda automatiza a adição do cliente nas configurações do servidor. Foi criado ainda um 
\textit{script} complementar, em Python, para ser obtido o ficheiro de configurações de maneira mais fácil para o utilizador/cliente. 
Este script segue o mesmo princípio da troca da base de dados, com a diferença de que está a utilizar a seu endereço de IP local em vez 
da VPN. Sendo assim, para obter o ficheiro de configurações, é necessário estabelecer conexão com o servidor no endereço 
\textit{192.168.1.106:9595 {nome}}, onde \textit{nome} é o nome do utilizador que quer aceder à VPN. Ao estabelecer ligação, vai ter 
um ficheiro de configurações criado por um administrador à espera de ser transferido. O administrador cria esse ficheiro com o auxilio do 
\textit{script} anterior, para conseguir limitar o acesso às comunicações caso o acesso à VPN seja comprometido.


\begin{verbatim}
    sudo firewall-cmd --add-port=8000/tcp --permanent
    sudo firewall-cmd --reload
\end{verbatim}

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Problemas Encontrados}\label{problemas}
Durante o desenvolvimento do projeto, foram encontrados alguns problemas, que foram resolvidos da seguinte forma:
%-------------------------------------------------------------------------------------------------
\subsection{Problemas de Conexão}
Logo no inicio da implementação da VPN foi necessário achar uma solução para a configuração de encaminhamento de pacotes, pois o servidor Linux
não possui um endereço IP público próprio. Para contornar este problema, foi necessário configurar o encaminhamento de pacotes no router, de forma
a que todos os pacotes que chegassem à porta 51820 fossem encaminhados para o servidor Linux, e este resolveria a situação encaminhando o resto dos pacotes pela VPN.\\
Outro problema encontrado foi a dificuldade em encontrar uma maneira para estabelecer a conexão pela primeira vez, ou seja, enviar o ficheiro de configuração
da VPN para o dispositivo do utilizador, de forma a que este pudesse estabelecer a conexão com o servidor. Para resolver este problema,
foi necessário criar um \textit{script} que gerasse o ficheiro de configuração do WireGuard, e que fosse possível enviar esse ficheiro para o dispositivo do utilizador.
%-------------------------------------------------------------------------------------------------
\subsection{Problemas na aplicação Windows/Android}
Durante o desenvolvimento da aplicação, foram encontrados diversos problemas, como por exemplo:
\begin{itemize}
	\item Problemas de compatibilidade entre tipos de base de dados (SQLite e Schemas);
	      \begin{itemize}
		      \item Incompatibilidade de nomes entre tabelas, sendo necessário colocar as tabelas em letra minúscula em ambos;
		      \item Configurações por defeito diferentes entre as plataformas, sendo necessário deixar explícito em ambos os lados 
              sobre as configurações necessárias, como por exemplo "\textit{NOT NULL}";
	      \end{itemize}
	\item Permissões do Android, sendo necessário adicionar todas as permissões necessárias no AndroidManifest.xml para funcionar corretamente;
	\item Visualização/sincronização incorreta das informações e a impossibilidade de modificar a base de dados enquanto a aplicação está a correr, sendo necessário 
	criar bases de dados temporárias para permitir a edição dos dados.
\end{itemize}

%-------------------------------------------------------------------------------------------------
\subsection{Depuração da camada criptográfica e protocolo de \textit{framing}}
\label{subsec:cripto-framing}
    	\textbf{Contexto.} A arquitetura Cliente Android (Kotlin) \(\leftrightarrow\) Servidor PC (Python) exige confidencialidade e integridade ponta-a-ponta. Foi adotado Serpent-256 em modo AEAD, com AAD a autenticar metadados. Em testes iniciais surgiram falhas consistentes de decriptação (\texttt{BAD\_DECRYPT}).

	\textbf{Sintomas observados.}
\begin{itemize}
    \item \texttt{BAD\_DECRYPT} repetido antes de qualquer \textit{plaintext} ser obtido.
    \item Comprimento de chave correto (32 bytes), AAD com 38 bytes constantes mas não padronizados.
    \item Falha idêntica entre várias “abordagens de compatibilidade”, sugerindo desalinhamento estrutural (nonce/tag/AAD) e não corrupção de dados.
    \item Envio rápido de duas mensagens causava paragens no receptor (``silêncio'') ou exceções intermitentes.
\end{itemize}

	\textbf{Metodologia de depuração.}
\begin{enumerate}[label=\alph*)]
    \item Instrumentação com \textit{logs} DEBUG antes/depois de: derivação de chave, montagem de AAD, geração/uso de nonce, chamada AEAD.
    \item \textit{Hexdump}/\textit{base64} lado-a-lado (cliente/servidor) de AAD, nonce, \textit{ciphertext}, tag; assertivas de tamanho de segmentos.
    \item Ensaios com \textit{scripts} Python isolando a decriptação e testes negativos (alteração de 1 byte para confirmar assinatura de falha).
    \item Validações com ferramentas auxiliares (\texttt{openssl dgst}, \texttt{hexdump -C}).
\end{enumerate}
\newpage
	\textbf{Hipóteses priorizadas.}
\begin{itemize}
    \item Divergência de modo AEAD (GCM/EAX) ou parâmetros.
    \item Nonce/IV com tamanho/ordem diferentes (p. ex., 12 vs 16 bytes) ou reutilização acidental.
    \item Tag truncada (12 vs 16 bytes) na serialização.
    \item Construção de AAD assimétrica (ordem, endianidade, inclusão/omissão de campos).
    \item Parâmetros de KDF distintos (\textit{salt}/\textit{info}).
    \item Fragilidade no \textit{framing}: concatenação de mensagens sem delimitador robusto e leituras parciais do \textit{socket}.
\end{itemize}

    % Explicação alargada e acessível sobre AEAD, GCM e EAX
    \paragraph{AEAD, GCM e EAX}
    AEAD (Authenticated Encryption with Associated Data) combina encriptação e autenticação numa única operação: cifra os dados para que ninguém os leia e, ao mesmo tempo, gera um selo (a chamada \textit{tag}) que comprova que os dados e certos metadados não foram alterados. Pensa nisto como enviar um envelope lacrado e com um selo de segurança — se o selo estiver danificado ou diferente, o recetor percebe que houve manipulação e rejeita a mensagem.

    Dois modos comuns para obter AEAD são GCM e EAX. Ambos fazem essencialmente o mesmo: cifram os dados e produzem uma \textit{tag} que o recetor verifica. As diferenças técnicas interessam aos implementadores, mas para entender o problema prático convém saber o seguinte:

    \begin{itemize}
        \item \textbf{GCM (Galois/Counter Mode)}: é muito utilizado e rápido. Normalmente espera um \textit{nonce} de 12 bytes e produz uma \textit{tag} de 16 bytes. Um requisito crítico do GCM é a unicidade do \textit{nonce} para cada mensagem quando a mesma chave é usada — reutilizar um \textit{nonce} pode quebrar a segurança.
        \item \textbf{EAX}: é outra construção AEAD que também cifra e gera uma tag, mas trata nonces e metadados de forma ligeiramente diferente. Funciona bem, mas não é compatível com GCM: se um lado usar GCM e o outro EAX, as tags não baterão e a decriptação falhará.
    \end{itemize}

    Em termos práticos, isto significa que o emissor e o recetor têm de concordar exatamente em: qual o modo (GCM ou EAX), o comprimento do \textit{nonce}, o comprimento da \textit{tag} e como se formam os metadados autenticados. Qualquer discrepância — modo diferente, nonce duplicado, tag truncada ou AAD com conteúdo diferente — faz com que a verificação falhe e a mensagem seja rejeitada (por exemplo com \texttt{BAD\_DECRYPT}).

    \paragraph{AAD}
    O AAD (Associated Authenticated Data) são informações que não são cifradas mas entram na criação do selo (tag). Exemplos: versão do protocolo, número de sequência, identificador de utilizador. O AAD protege estes campos contra alterações, mas exige que emissor e recetor tenham exactamente os mesmos bytes em AAD; qualquer diferença causa falha na verificação.

    \paragraph{KDF }
    Um KDF (Key Derivation Function) transforma uma chave mestra ou palavra‑passe num conjunto de chaves de uso (por exemplo: chave de encriptação, prefixo de nonce). Parâmetros como \textit{salt}, número de iterações e informação adicional (\textit{info}) têm de ser os mesmos nos dois lados; se não, as chaves diferirão e a decriptação não funcionará.

    \paragraph{Framing }
    TCP é um fluxo contínuo de bytes: pacotes enviados separadamente pelo emissor podem chegar agrupados ou fragmentados. \textbf{Framing} é o acordo que define onde começa e acaba cada mensagem (por exemplo usar um prefixo de comprimento de 4 bytes). Sem framing robusto, o recetor pode tentar decriptar dados incompletos ou várias mensagens coladas, levando a erros de autenticação (\texttt{BAD\_DECRYPT}) e problemas subsequentes no processamento.

    
    
    
                	extbf{Normalização do envelope e \textit{framing} (explicação detalhada)}
Para remover ambiguidade em troca de mensagens sobre TCP definimos um contrato binário claro e passos de validação obrigatórios no receptor. O envelope tem sempre um \emph{length-prefix} de 4 bytes (\textbf{big-endian}) que indica o comprimento total do restante \textit{frame} e permite ao recetor saber quando tem um \textit{frame} completo.

Formato canónico (campo : tamanho em bytes — descrito por ordem de leitura):
\begin{itemize}
    \item \textbf{LEN (4)}: comprimento (em bytes) de tudo o que vem a seguir no \textit{frame}.
    \item \textbf{MAGIC (2)}: identificador do protocolo (p. ex. 0x50 0x53 para "P S").
    \item \textbf{VER (1)}: versão do envelope/protocolo.
    \item \textbf{ALG (1)}: código do algoritmo (ex.: 1=AES, 2=SERPENT) — armazenado ofuscado no cabeçalho quando aplicável.
    \item \textbf{FLAGS (1)}: flags de uso futuro (compactação, fragmentação, indicadores de diagnóstico).
    \item \textbf{SEQ (8)}: contador monotónico de mensagem (big‑endian) — usado no AAD e na derivação do \textit{nonce}.
    \item \textbf{TIMESTAMP (8)}: marca temporal para diagnóstico (opcional na verificação temporal).
    \item \textbf{NONCE (12)}: nonce/IV usado pelo AEAD (a nossa prática: 4 bytes prefixo derivado da chave + 8 bytes de SEQ, total 12 bytes).
    \item \textbf{TAG (16)}: etiqueta de autenticação AEAD (16 bytes, sem truncagem).
    \item \textbf{AAD\_LEN (2)}: comprimento em bytes do campo AAD.
    \item \textbf{CT\_LEN (4)}: comprimento em bytes do \textit{ciphertext}.
    \item \textbf{AAD}: campo de metadados autenticados (tamanho AAD\_LEN).
    \item \textbf{CIPHERTEXT}: dados cifrados (tamanho CT\_LEN) imediatamente seguidos do \textbf{TAG} já presente acima.
\end{itemize}

Notas práticas e motivo das escolhas:
\begin{itemize}
    \item Usar \textbf{LEN(4)} evita ambiguidade em streams TCP — o receptor acumula até LEN bytes e só depois processa o \textit{frame} completo.
    \item Colocar \textbf{SEQ} no AAD e usá-lo para formar o \textbf{NONCE} (por exemplo: NONCE = SHA256(key)\verb|[:4]| \texttt{||} SEQ) garante unicidade por mensagem e rastreabilidade.
    \item Reservar um campo \textbf{TAG} de 16 bytes e não a truncar reduz riscos de falsificação; qualquer truncagem deve ser documentada e deprecada.
    \item Documentar explicitamente a ordem e a endianidade de cada campo evita erros por diferenças de implementação.
\end{itemize}

Regras de segurança e robustez (obrigatórias):
\begin{itemize}
    \item Validar limites máximos (p. ex. AAD\_LEN < 4096, CT\_LEN < $10^7$) antes de alocar buffers para evitar DoS por mensagens gigantes.
    \item Fazer comparações da TAG em tempo constante; limpar buffers e chaves sensíveis após uso.
    \item Nunca assumir que um único \texttt{read()} do socket corresponde a exactamente um \textit{frame} — por isso o BufferAssembler existe.
    \item Em caso de \texttt{AEAD\_FAIL} registar um dump hex do AAD/nonce/tag apenas em modo debug e com limitação de taxa para não vazar segredos em logs de produção.
\end{itemize}

Implementações e salvaguardas recomendadas
\begin{itemize}
    \item \textbf{BufferAssembler no receptor}: componente que acumula bytes lidos do socket, lê LEN quando possível e só entrega frames completos ao pipeline de decifração.
    \item \textbf{Sequência monotónica (SEQ)}: incluir SEQ no AAD e na derivação do NONCE; rejeitar mensagens com SEQ duplicado ou regressivo (janela aceitável para reenvios controlada).
    \item \textbf{Self‑test no arranque}: cifra/decifra um vetor conhecido para garantir compatibilidade do AEAD e dos parâmetros; abortar se o self‑test falhar.
    \item \textbf{Backpressure e ACKs}: durante diagnóstico usar ACKs/pausas para evitar ráfagas; em produção garantir que o pipeline aplica limites e filas para escrita na BD.
    \item \textbf{Logs estruturados}: registar contadores de \texttt{AEAD\_FAIL} e tipos de erro; dumps binários só em debug com rotação e retenção curta.
\end{itemize}

Bug observado: "duas mensagens consecutivas" — explicação técnica curta
\begin{itemize}
    \item Causa típica: leituras do socket que retornam parte de um frame seguido de parte do frame seguinte, e um receptor que tenta decifrar imediatamente sem acumular o frame completo; o resultado é que campos deslocam‑se (nonce/tag/AAD lidos do lugar errado) e a verificação AEAD falha.
    \item Mitigação: implementar o BufferAssembler + length‑prefix e processar frames apenas quando completos; serializar gravações na BD (worker/fila) e usar transacções atómicas para evitar corrupção em caso de mensagens inválidas.
\end{itemize}
 
% --- detalhe adicionado: logs, reprodução e recomendações ---
\paragraph{Caso observado: logs e impacto prático}
Durante a instrumentação foi detectado um padrão de erro quando o servidor tenta decifrar pacotes com Serpent: mensagens como
	\texttt{"Serpent compatibility decryption failed: All Serpent compatibility approaches failed"} seguidas de \texttt{BAD\_DECRYPT} aparecem no receptor (imagem de debug anexada). Estes sinais correspondem à falha da verificação AEAD — tipicamente causada por divergência nos campos autenticados (AAD), no \textit{nonce} ou por leitura/parsing incorreto do envelope.

\paragraph{Reprodução e efeito sobre a base de dados}
Verificámos um cenário replicável que provoca corrupção/queda da base de dados no PC quando o cliente Android envia duas mensagens muito próximas em tempo. Exemplo reproduzível:
\begin{enumerate}
    \item PC: OLA
    \item ANDROID: SUP1
    \item ANDROID: SUP2
\end{enumerate}
Ao enviar assim (duas mensagens consecutivas do Android) o receptor recebe \textit{frames} concatenados ou incompletos, tenta decifrá-los e falha (\texttt{BAD\_DECRYPT}), o que, nas implementações observadas, pode conduzir a escrita inválida na base de dados ou a estados em que a BD deixa de responder.

\paragraph{Diagnóstico e medidas imediatas}
Observações feitas durante a depuração:
\begin{itemize}
    \item Comparação lado-a-lado (hex) de AAD/nonce/tag mostra diferenças entre emissor e recetor quando ocorre a falha.
    \item Reenvio isolado do mesmo envelope normalmente decifra correctamente, pelo que o problema não parece ser corrupção permanente dos bytes.
    \item Condições de corrida no processamento e parsing de \textit{streams} TCP são a causa provável.
\end{itemize}
Medidas imediatas aplicadas:
\begin{itemize}
    \item Forçar processamento sequencial no receptor com um \textit{BufferAssembler} que reconstitui frames completos antes de qualquer operação criptográfica.
    \item Introduzir ACK/backpressure em fases de diagnóstico para evitar ráfagas de mensagens concorrentes.
    \item Garantir que cada escrita na BD ocorre dentro de transacções atómicas para evitar corrupção parcial.
\end{itemize}

\paragraph{Recomendações para correção definitiva}
\begin{itemize}
    \item Implementar o \textit{length-prefix} (4 bytes big-endian) e usar um \textit{BufferAssembler} robusto no receptor para evitar decifrações de dados incompletos.
    \item Serializar o acesso à base de dados através de um worker dedicado ou fila de escrita e usar transacções/WAL para tolerância a ráfagas.
    \item Validar comprimentos de AAD/nonce/tag antes de chamar a decriptação; registar dumps hex apenas em modo debug e com limitação de taxa.
    \item Assegurar unicidade de nonce por mensagem (por exemplo: NONCE = prefixo chave || SEQ monotónico) e separar responsabilidades de KDF para evitar reutilização indevida de material criptográfico.
\end{itemize}


	\textbf{Resultados e validação.}
\begin{itemize}
    \item Eliminação do ``silêncio'' após ráfagas curtas e ausência de \texttt{BAD\_DECRYPT} nas execuções instrumentadas.
    \item \textit{Stress tests} internos com pares de mensagens (intervalos 30--250 ms) sem \textit{crash}; \textit{logs} confirmam \textbf{SEQ} crescente e \textit{frames} completos.
    \item Critérios de fecho definidos: 0 ocorrências \texttt{BAD\_DECRYPT} em campanhas prolongadas; 100 envios duplos consecutivos sem \textit{crash}; latência média $< 150$ ms; \textbf{SEQ} sem desvios não explicados.
\end{itemize}

	\textbf{Lista de verificação (antes de nova tentativa).}
\begin{itemize}
    \item Mesmo algoritmo e modo AEAD nos dois lados; \textbf{TAG=16B}, \textbf{NONCE=12B} único.
    \item \textbf{KDF} com \textit{salt}/\textit{info} idênticos; AAD determinística e documentada.
    \item \textbf{Framing} com \textbf{LEN(4)} ativo; tratamento de exceções não encerra o processo.
    \item \textbf{Self-test} no arranque aprovado.
\end{itemize}

	\textbf{Lições aprendidas.} A principal fonte de instabilidade não era apenas a cifra, mas a ausência de um contrato binário formal 
    (layout de envelope + AAD + \textit{framing}). Ao fixar cada campo e a sua semântica, reduziram-se incompatibilidades e simplificou-se 
    a depuração. A unicidade do nonce derivado de \textbf{SEQ} e a instrumentação detalhada foram determinantes para estabilizar o sistema.

\medskip
\textbf{Fundamentação teórica (AEAD, AAD, nonces e framing).}
\begin{itemize}
    \item \textbf{AEAD} (\textit{Authenticated Encryption with Associated Data}) combina confidencialidade e integridade: a decriptação falha integralmente se qualquer bit do \textit{ciphertext}, da \textbf{TAG} ou da \textbf{AAD} estiver alterado. Isto previne ataques de manipulação e “corta e cola”.
    \item \textbf{AAD} é não cifrada mas autenticada; deve incluir metadados que definem o contexto (p. ex., versão, algoritmo, \textbf{SEQ}, \textbf{USER\_ID}). Divergências entre emissor e recetor provocam \texttt{BAD\_DECRYPT} por falha na verificação da TAG.
    \item O tamanho da \textbf{TAG} (tipicamente 16 bytes) é um compromisso entre segurança e espaço. Truncagens elevam o risco de falsificações bem-sucedidas.
    \item \textbf{Nonces/IVs} em modos como GCM/EAX devem ser \emph{únicos por chave}. Reutilização de nonce compromete a confidencialidade e pode afetar a integridade.
\end{itemize}

\textbf{Modos AEAD e requisitos de nonce.}
\begin{itemize}
    \item \textbf{GCM}: desempenho elevado; nonce recomendado de 96 bits (12 bytes) e unicidade estrita por chave.
    \item \textbf{EAX/OCB}: alternativas com requisitos semelhantes de unicidade. OCB teve restrições de patente históricas.
    \item \textbf{SIV} (\textit{Synthetic IV}): tolera reutilização de nonce, adequado quando a unicidade não é garantida, à custa de desempenho.
    \item \textbf{Prática adotada}: NONCE = prefixo derivado da chave || \textbf{SEQ} (12 bytes), garantindo unicidade se \textbf{SEQ} for monotónico por sessão.
\end{itemize}

\textbf{Derivação e separação de chaves (KDF).}
\begin{itemize}
    \item Utilize \textbf{HKDF} com \textit{salt} e \textit{info} para derivar chaves de sessão a partir de uma raiz, aplicando \emph{domain separation} para \textit{encrypt}, \textit{mac}, \textit{nonce-prefix}, etc.
    \item Evite reutilizar a mesma chave para múltiplos propósitos; separe por função para reduzir o acoplamento e facilitar auditoria.
    \item Considere rotação por tempo ou contagem; registe \textbf{VER}/\textbf{ALG} no envelope para agilidade criptográfica.
\end{itemize}

\textbf{Framing em canais de \textit{byte-stream} (TCP).}
\begin{itemize}
    \item TCP pode fragmentar ou coalescer envios; o recetor deve reconstituir \textit{frames} completos.
    \item Um \textbf{length-prefix} fixo (4 bytes big-endian) torna os \textit{frames} auto-delimitados e evita ambiguidades.
    \item Defina \textbf{limites máximos} por \textit{frame} e valide \textbf{LEN} antes de alocar/copiar; implemente um \textit{BufferAssembler} que apenas decifra após \textit{frame} completo.
\end{itemize}

\textbf{Proteções adicionais.}
\begin{itemize}
    \item \textbf{SEQ} monotónico, janela anti-\textit{replay} e \textbf{TIMESTAMP} para diagnóstico e controlo de ritmo.
    \item Comparação de \textbf{TAG} em tempo constante; limpeza de chaves e \textit{buffers} sensíveis quando possível.
    \item Erros genéricos no protocolo e \textit{logs} internos detalhados com limitação de taxa.
\end{itemize}

\textbf{Testes e verificação.}
\begin{itemize}
    \item \textbf{Vetores de teste} determinísticos no arranque (\textit{self-test}).
    \item \textbf{Fuzzing} do \textit{BufferAssembler} e do desserializador; testes de propriedades (\textit{round-trip}, rejeição a \textit{bitflips}).
    \item Testes negativos: nonce repetido, TAG truncada, AAD alterada; \textbf{stress tests} com ráfagas e latências variáveis.
\end{itemize}

\section{Testes}\label{testes}
Os testes realizados tem como base 2 metodos:
\begin{itemize}
	\item Verificação da base de dados através do servidor
	\item Sniffing das comunicações com o uso do Wireshark
\end{itemize}
%-------------------------------------------------------------------------------------------------
\subsection{Servidor}
Os testes realizados no servidor foram focados na verificação da base de dados e na monitorização das comunicações.
Para a verificação da base de dados, é feita a tentativa de ler o ficheiro enviado, e como é possivel verificar nas figuras abaixo,
ao ler o ficheiro sem criptografia, é possível visualizar o seu conteúdo perfeitamente, ao ler o ficheiro com criptografia,
não é possível visualizar o seu conteúdo pois o servidor guarda a base de dados sem desencriptar, isto leva a que o ficheiro nem seja reconhecido como uma base de dados.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{Recursos/DBNormal.png}
        \caption{Sem Criptografia}
        \label{fig:db_normal}
    \end{subfigure}
    \vskip 2cm
    \begin{subfigure}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{Recursos/DBEncriptada.png}
        \caption{Com Criptografia}
        \label{fig:db_encriptada}
    \end{subfigure}
    \caption{Teste com Servidor}
    \label{fig:wireshark_msg_duas_imagens}
\end{figure}
\newpage
%-------------------------------------------------------------------------------------------------   
\subsection{Comunicações}
Para a monitorização das comunicações, foi utilizado o Wireshark para fazer sniffing dos pacotes que estavam a ser enviados e recebidos pelo servidor.
Como é possivel ver nas figuras abaixo, estes são os resultados:

\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{1.05\textwidth}
        \includegraphics[width=\textwidth]{Recursos/WiresharkNormalMSG.png}
        \caption{Sem Criptografia}
        \label{fig:wireshark_normal_fora}
    \end{subfigure}

    % Espaço vertical entre as imagens
    \vskip 1cm

    \begin{subfigure}[b]{1.05\textwidth}
        \includegraphics[width=\textwidth]{Recursos/WiresharkEncriptadaMSG.png}
        \caption{Com Criptografia}
        \label{fig:wireshark_encriptado_fora}
    \end{subfigure}
    \caption{Teste com Servidor}
    \label{fig:duas_imagens}
\end{figure}
Para obter esta captura, foi necessário selecionar dentro do Wireshark o adaptador associado à VPN para ver o tráfego que passa lá dentro. Ao analisar o resultado obtido pelo
Wireshark não é possível detetar nenhuma diferença óbvia, sem ser a questão do aparecimento do \textit{(text/html)} nas mensagens criptografadas. 
Isto, só se vai tornar mais visível, quando for selecionada a mensagem, e com o botão direito do rato, selecionar depois a opção \textit{Follow --> TCP Stream},
isto fará com que apareçam os resultados das figuras \ref{fig:wireguard_normal} e \ref{fig:wireguard_encriptado}.

\newpage
Sendo assim, podemos analisar o conteúdo desta mensagem 
HTTP, sendo ele na figura \ref{fig:wireguard_normal} a estrutura da base de dados nas fases iniciais do projeto, onde ainda não estava criptografada. Ao analisar o conteúdo após,
seria possível visualizar todas as informações da base de dados, incluindo utilizadores, mensagens e outros dados sensíveis.
\begin{figure}[h]
        \centering
        \includegraphics[width=0.7\textwidth]{Recursos/WiresharkNormal.png}
        \caption{Wireshark Sem Criptografia}
        \label{fig:wireguard_normal}
\end{figure}
\newpage
Agora, ao analisar o conteúdo da figura \ref{fig:wireguard_encriptado}, podemos ver que a estrutura da base de dados está ilegível para um
ser humano devido à criptografia AES256/Serpent, sendo impossível saber o conteúdo se não for feita a decriptação, e para isto ocorrer 
é necessário ter acesso à chave, seja para "desenvolopar", seja para desencriptar. Isto garante a segurança 
das comunicações caso o acesso à VPN seja comprometido, e uma pessoa não autorizada consiga aceder ao tráfego que passa pela VPN.
\begin{figure}[h]
    \centering
        \includegraphics[width=0.7\textwidth]{Recursos/WiresharkEncriptada.png}
        \caption{Wireshark Com Criptografia}
        \label{fig:wireguard_encriptado}
\end{figure}


%---------------------------------------------------------------------------------------------------------------------------
\section{Melhorias Futuras}
Este projeto está sujeito a imensas melhorias, tais como:
\begin{itemize}
    \item Implementação de novas funcionalidades, como mensagens de voz/chamadas criptografadas;
    \item Melhoria da interface do utilizador;
    \item Aumento da segurança das comunicações, adicionando HTTPS em vez de HTTP.
\end{itemize}
%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Conclusão}\label{con}
Concluimos assim que o projeto foi um sucesso, pois conseguimos desenvolver um sistema de comunicações seguras
que permite a troca de mensagens de texto entre os seus utilizadores, sem que haja a possibilidade de terceiros acederem às mensagens trocadas.
Em geral, foi um projeto que nos permitiu aprender bastante sobre a área de cibersegurança e comunicações seguras,
e que nos possibilitou aplicar os conhecimentos adquiridos ao longo do curso de Engenharia Informática.
%---------------------------------------------------------------------------------------------------------------------------

\newpage
\renewcommand{\refname}{Bibliografia} % Para artigos
\renewcommand{\bibname}{Bibliografia} % Para livros e relatórios
\addcontentsline{toc}{section}{Bibliografia} % Adiciona a Bibliografia ao índice
\printbibliography
\newpage
\end{document}
