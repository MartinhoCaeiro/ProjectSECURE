\documentclass[a4paper]{article}
\usepackage[portuguese]{babel}
\usepackage[backend=biber, style=apa, citestyle=apa, language=portuguese]{biblatex}
\usepackage{csquotes}
\addbibresource{Recursos/referencias.bib}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{setspace}
\usepackage{siunitx} % Required for alignment
\sisetup{
  round-mode          = places, % Rounds numbers
  round-precision     = 2, % to 2 places
}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{karnaugh-map}
\usepackage[section]{placeins}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{titling}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{xcolor}
\usepackage{indentfirst}
\usepackage{array}
\usepackage{wrapfig} % Coloca isto no preâmbulo
\usepackage{soul}
\usepackage{afterpage}
\usepackage[toc,page]{appendix}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
% Código: listings para incluir trechos de código no relatório
\usepackage{listings}
\usepackage{courier}
\lstdefinelanguage{Kotlin}{
    keywords={package,import,object,fun,val,var,private,const,if,else,return,require,when,as,is},
    morekeywords={ByteArray,SecureRandom,Cipher,GCMParameterSpec,SecretKeySpec,AEADParameters,PKCS5S2ParametersGenerator,SHA256Digest},
    sensitive=true,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    string=[b]"
}
\lstset{
    language=Kotlin,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray},
    stringstyle=\color{orange},
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    captionpos=b
}


% Comando para criar uma página vazia
\newcommand\myemptypage{
    \null
    \thispagestyle{empty}
    \addtocounter{page}{-1}
    \newpage
}

% Página de título principal
\newcommand{\firsttitlepage}{
    \begin{titlepage}
        \centering
        
        % Logos superior
        \begin{figure}[h!]
            \centering
            \includegraphics[width=6cm]{Recursos/Logos/LOGO_IPB} % Substitua pelo caminho da imagem
            \vspace{0.5cm}
        \end{figure}    
        % Informações da instituição
        \large\textbf{INSTITUTO POLITÉCNICO DE BEJA} \\
        \large\textbf{Escola Superior de Tecnologia e Gestão} \\
        \large\textbf{Licenciatura em Engenharia Informática} \\
        \large\textbf{Projeto Final de Curso} \\
        
        
        % Título do projeto
        {\Huge \textbf{Desenvolvimento de um sistema de comunicações seguras }} \\
        
        \vspace{1cm}
        
        % Autores
    
        \large Martinho José Novo Caeiro - 23917 \\
        \large Paulo António Tavares Abade - 23919 \\
        \large Rafael Conceição Narciso - 24473 \\
        
        \vfill
        
        % Logo inferior
        \begin{figure}[h!]
            \centering
            \includegraphics[width=6cm]{Recursos/Logos/IPBejaESTIG.jpg} % Substitua pelo caminho da imagem
        \end{figure}
        
        % Local e data
        {\large Beja, setembro de 2025}
    \end{titlepage}
}

\newcommand{\secondtitlepage}{
    \begin{titlepage}
        \centering
        \vspace*{1cm}
        
        % Informações da instituição
        \large\textbf{INSTITUTO POLITÉCNICO DE BEJA} \\
        \large\textbf{Escola Superior de Tecnologia e Gestão} \\
        \large\textbf{Licenciatura em Engenharia Informática} \\
        \large\textbf{Projeto Final de Curso} \\
        
        \vspace{2cm}
        
        % Título do projeto
        {\Huge \textbf{Desenvolvimento de um sistema de comunicações seguras }} \\
        
        \vspace{1.5cm}
        
        % Autores
        \large Martinho José Novo Caeiro - 23917 \\
        \large Paulo António Tavares Abade - 23919 \\
        \large Rafael Conceição Narciso - 24473 \\

        \vspace{2cm}

        % Orientador
        \large Orientador: Professor Rui Miguel Soares Silva \\
        
        \vfill
        
        % Local e data
        {\large Beja, setembro de 2025}
    \end{titlepage}
}

\begin{document}


\pagenumbering{gobble} % Oculta numeração da página

% Primeira página de título
\firsttitlepage

\secondtitlepage


% Abstract
\section*{\LARGE\textbf{\textit{Resumo}}}

Neste relatório será abordado o processo de criação de uma solução de comunicações seguras,
que permita a troca de mensagens de texto entre os seus utilizadores.
Este relatório foi realizado no âmbito da Unidade Curricular de
Estágio ou Projeto (\cite{pagep}).


\vspace{1cm}
% Keywords
\textbf{Keywords:} aplicações, cibersegurança, comunicações, criptografia, c\#, python, bash, almalinux, wireguard, sqlite, kotlin
\newpage
%--------------------------------------------------------------------------------------------------------------------------------------

\section*{\LARGE\textbf{\textit{Abstract}}}

In this report, we will address the creation process of a secure communication
solution that allows text message exchange between its users.
This report was carried out within the scope of the
Curricular Unit of Internship or Project (\cite{pagep}).


\vspace{1cm}
% Keywords
\textbf{Keywords:} applications, cybersecurity, communications, cryptography, c\#, python, bash, almalinux, wireguard, sqlite, kotlin
\renewcommand{\contentsname}{Índice}       % Título do sumário
\renewcommand{\listfigurename}{Índice de Figuras} % Título da lista de figuras

% Início do conteúdo do relatório
\newpage
\doublespacing
\tableofcontents
\newpage
\listoffigures
\doublespacing

\newpage
\pagenumbering{arabic}

\section{Introdução}\label{intro}
Para a realização do projeto é necessário desenvolver um sistema de comunicações seguras, que permita a troca de mensagens de texto entre os seus utilizadores.
Para tal, é necessário implementar um sistema de autenticação de utilizadores, que permita a criação de contas de utilizador e a autenticação dos mesmos.
O sistema deve ser capaz de garantir a confidencialidade, integridade e autenticidade das mensagens trocadas entre os utilizadores. As tecnologias a utilizadas
no desenvolvimento deste projeto são: WireGuard (\cite{wireguard}), SQLite (\cite{sqlite}), C\# (\cite{csharp}), Kotlin (\cite{kotlin}), Python (\cite{python}),
Bash (\cite{bash}), AlmaOS (\cite{almaos}). Em relação a criptografia, serão utilizados os algoritmos Rijndael (vencedor do AES) e
Serpent (segundo lugar do AES), que são algoritmos de criptografia simétrica.

Para este projeto, foi decidido utilizar uma variação da metodologia do \textit{SCRUM}, onde eram realizadas reuniões semanais ao ínicio, e depois
foi sendo feito para ocorrer mais tempo entre reuniões, de forma a que fosse possível ter mais tempo para o desenvolvimento das
tarefas. Os três membros da equipa foram divididos entre as três áreas do projeto, nomeadamente: desenvolvimento da aplicação Windows,
desenvolvimento da aplicação Android e por último, a configuração da infraestrutura da rede.

O cronograma do projeto foi dividido em duas fases principais: Análise de Requisitos, Desenvolvimento, como é possível
ver na figura \ref{fig:project_schedule}. O relatório foi modificado a cada semana, acrescentando novas informações e
atualizações sobre o progresso do projeto.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/Cronograma.png}
	\caption{Cronograma do Projeto}
	\label{fig:project_schedule}
\end{figure}

Este projeto ficou guardado nos repositórios do GitHub da equipa, onde pode ser consultado por outros alunos e professores, a partir do seguinte
link:\\ \url{https://github.com/MartinhoCaeiro/Projeto-Cripto} \&  \url{https://github.com/NarcisoUNK/ProjectFinal_ANDROID}.
%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Analise de Requisitos}\label{analise}
Para a realização deste projeto, após ser idealizado entre os membros da equipa e analisadas outras aplicações de troca de mensagens, como o \textit{WhatsApp} (\cite{whatsapp}) 
e \textit{Telegram} (\cite{telegram}), para compreender como estas funcionam. Chegando à conclusão de que utilizam
uma encriptação de ponta a ponta para garantir a segurança das mensagens. Neste projeto, será implementada uma abordagem 
bastante semelhante, porém com a integração da VPN. A ideia da VPN surgiu após uma conversa entre os membros da equipa, onde foi discutido o que aconteria se o tráfego da aplicação 
fosse encaminhado através de uma VPN, e assim a equipa concluiu que isso garantiria uma camada extra de segurança.
Sendo assim, foram definidos os seguintes requisitos funcionais e não funcionais:
\begin{itemize}
	\item \textbf{Requisitos Funcionais:}
	      \begin{itemize}
		      \item O sistema deve permitir a criação de contas de utilizador.
		      \item O sistema deve permitir a autenticação de utilizadores.
		      \item O sistema deve permitir o envio e receção de mensagens entre utilizadores.
		      \item O sistema deve garantir a confidencialidade, integridade e autenticidade das mensagens trocadas.
	      \end{itemize}
	\item \textbf{Requisitos Não Funcionais:}
	      \begin{itemize}
		      \item O sistema deve ser seguro e resistente a ataques.
		      \item O sistema deve ser fácil de usar e intuitivo.
		      \item O sistema deve ser escalável e capaz de suportar um grande número de utilizadores.
	      \end{itemize}
\end{itemize}



%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Tecnologias Utilizadas}\label{tecnologias}
Para o desenvolvimento deste projeto, foram utilizadas as seguintes tecnologias:
\begin{itemize}
	\item \textbf{Linguagens de Programação:} C\#, Kotlin
	\begin{itemize}
        \item C\#: Utilizada para o desenvolvimento da aplicação de desktop (Windows), outra possibilidade seria Java, porém 
        foi escolhido C\# por ter sido utilizada há pouco tempo em outra unidade curricular.
        \item Kotlin: Utilizada para o desenvolvimento da aplicação Android, outra possibilidade seria também Java, porém
        foi escolhido Kotlin por ser uma linguagem mais moderna e concisa, e ter sido utilizada recentemente em outra unidade curricular.
    \end{itemize}
	\item \textbf{Frameworks:} .NET, WireGuard
	\begin{itemize}
        \item .NET: Utilizada para o desenvolvimento da aplicação de desktop (Windows), e decidimos por ter sido utilizada recentemente em outra unidade curricular.
        \item WireGuard: Utilizada para a implementação da VPN, por ser uma solução de VPN moderna, leve e de alto desempenho, e após pesquisas, foi visto que funcionava sem problemas
        em AlmaOS 8.10 e que era fácil de configurar nos dispositivos clientes.
    \end{itemize}
	\item \textbf{Base de Dados:} SQLite
	\begin{itemize}
        \item Por ser um sistema de gestão de base de dados relacional leve, rápido e fácil de usar.
    \end{itemize}
	\item \textbf{Criptografia:} Rijndael (Vencedor AES), Serpent (Segundo lugar AES)
	\begin{itemize}
        \item Foram escolhidos por serem algoritmos de criptografia simétrica seguros e eficientes, e por serem amplamente utilizados em aplicações de segurança. Foi recomendado 
        pelo professor orientador.
    \end{itemize}
	\item \textbf{Ferramentas de Desenvolvimento:} Git, Visual Studio Code, Android Studio, GitHub
	\begin{itemize}
        \item Todos os membros da equipa utilizam todas estas ferramentas, por serem ferramentas de desenvolvimento modernas, eficientes e fáceis de usar.
    \end{itemize}
\end{itemize}

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Arquitetura do Sistema}\label{arquitetura}
O sistema é composto por uma aplicação que funcionará como um chat, onde os utilizadores que estiverem registados na VPN poderão comunicar entre si.
Dentro da aplicação, os utilizadores podem saber quem está associado a um endereço IP da VPN, e assim enviar mensagens para esse utilizador.
Ao enviar uma mensagem, a aplicação irá contatar o servidor da VPN, para obter o caminho até ao destinatário, e assim enviar a mensagem.
Essa mensagem será encriptada antes de ser enviada, para garantir a confidencialidade e integridade da mensagem. Existe a variação
da encriptação utilizada na mensagem, de acordo com uma lógica pré-definida na aplicação, sendo que as cifras de encriptação utilizadas são o AES
e o Serpent.
%---------------------------------------------------------------------------------------------------------------------------
\subsection{Estrutura}
A estrutura do sistema é focada na troca de informação por dentro da VPN, podendo ser representada 
na seguinte figura \ref{fig:system_architecture}: 
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Recursos/SistemaFisico.png}
    \caption{Arquitetura do Sistema}
    \label{fig:system_architecture}
\end{figure}
\newpage
%---------------------------------------------------------------------------------------------------------------------------
\subsection{Encriptação}
O processo de encriptação das mensagens será feita como está demonstrado na figura \ref{fig:encryption_process}. A mensagem
será encriptada consoante um número pseudo-aleatório gerado pela aplicação, sendo assim escolhido o algoritmo de encriptação a utilizar naquele momento, o AES256 ou Serpent.
Para encriptar, é necessário fornecer também uma chave de encriptação. Nesta fase, a chave de encriptação é "\textit{\textbf{Spartacus}}". É importante destacar que o seletor 
está ofuscado, de forma a dificultar a sua identificação, a partir de uma máscara criada através da chave (\textit{salt}) e do número pseudo-aleatório.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/Encripta.png}
	\caption{Processo de Encriptação das Mensagens}
	\label{fig:encryption_process}
\end{figure}

\newpage

Para desencriptar, é necessário fazer o processo inverso. Desta forma, o número pseudo-aleatório está anexado à mensagem encriptada,
permitindo assim descobrir qual o algoritmo de encriptação utilizado. É possível ver este processo na figura \ref{fig:decryption_process}.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/Decripta.png}
	\caption{Processo de Decriptação das Mensagens}
	\label{fig:decryption_process}
\end{figure}


%---------------------------------------------------------------------------------------------------------------------------

\subsection{Implementação da Criptografia (excerto)}

O projecto inclui um módulo chamado \texttt{DbCrypto} (implementado em Kotlin/Java) responsável por encapsular a encriptação e desencriptação dos conteúdos armazenados.
Segue-se um excerto explicativo com os pontos-chave e um trecho do código mais relevante.

\paragraph{Resumo da lógica}
\begin{itemize}
  \item Gera-se um \textbf{salt} e um \textbf{nonce} aleatórios para cada encriptação.
  \item Deriva-se uma chave simétrica (256 bits) a partir da passphrase/\textit{masterKey} usando PBKDF2-SHA256 (100k iterações).
  \item Calcula-se uma máscara (\textit{mask}) para ofuscar qual o algoritmo usado (AES ou Serpent) e guarda-se o valor ofuscado no cabeçalho.
  \item Usa-se AES-GCM ou Serpent-GCM (via BouncyCastle) com AAD contendo o cabeçalho (magic, versão, algoritmo-ofuscado, iterações, salt e nonce).
  \item O ficheiro resultante é: cabeçalho || ciphertext || tag.
\end{itemize}

\paragraph{Trecho de código}
\begin{lstlisting}[caption={Excerto de \texttt{DbCrypto} — função de encriptação}]
private fun encryptInternal(data: ByteArray, masterKey: ByteArray, salt: ByteArray, nonce: ByteArray, alg: Alg): ByteArray {
    val key = deriveKey(masterKey, salt, ITERATIONS)
    val mask = computeAlgMask(masterKey, salt)
    val algXor = (alg.code.toInt() xor (mask.toInt() and 0xFF)).toByte()
    val aad = buildHeader(algXor, ITERATIONS, salt, nonce) // full header is AAD
    val ctWithTag = if (alg == Alg.AES) {
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, "AES"), GCMParameterSpec(TAG_SIZE * 8, nonce))
        cipher.updateAAD(aad)
        cipher.doFinal(data)
    } else {
        val gcm = GCMBlockCipher(SerpentEngine())
        gcm.init(true, AEADParameters(KeyParameter(key), TAG_SIZE * 8, nonce, aad))
        val out = ByteArray(gcm.getOutputSize(data.size))
        var len = gcm.processBytes(data, 0, data.size, out, 0)
        len += gcm.doFinal(out, len)
        out.copyOf(len)
    }
    return envelope(algXor, salt, nonce, ctWithTag)
}
\end{lstlisting}

\paragraph{Preview / Exemplo de validação}
Para validar o comportamento foi utilizada a função de desencriptação que verifica o cabeçalho, desfaz a máscara do algoritmo,
re-deriva a chave com os mesmos parâmetros e tenta a desencriptação; a produção correcta deverá retornar o conteúdo SQLite original (verifica-se o "magic" do SQLite).


\section{Módulos do Sistema}\label{modulos}

\subsection{Interface}
A interface para computador será desenvolvida em C\#, uma linguagem rápida e fácil de aprender, e que permite o desenvolvimento de aplicações desktop de forma eficiente e a interface 
para Android será desenvolvida em Kotlin, que é uma linguagem de programação moderna e concisa, que permite o desenvolvimento de aplicações Android de forma eficiente.
Esta interface é composta por 4 ecrãs principais:
\begin{itemize}
	\item \textbf{Ecrã de Login:} onde o utilizador pode autenticar-se na aplicação utilizando as suas credenciais, tambem é possivel ver o status da ligação WireGuard.
	\item \textbf{Ecrã de Lista de Chats:} onde o utilizador pode ver a lista de chats existentes, bem como criar novos chats.
	\item \textbf{Ecrã de Chat:} onde o utilizador pode enviar e receber mensagens de outros utilizadores.
	\item \textbf{Ecrã de Configuração WireGuard:} onde o utilizador pode criar um ficheiro para configuração do WireGuard.
\end{itemize}

\subsection{Módulo da VPN}
A VPN estará alojada num servidor com o sistema operativo AlmaOS 8.10 (\cite{almaos}), e será responsável por gerir as ligações dos utilizadores à VPN,
bem como a autenticação dos mesmos. A solução escolhida foi o WireGuard, que é uma solução de VPN de código aberto,
leve e de alto desempenho, que utiliza criptografia moderna para garantir a segurança das comunicações. É necessário configurar previamente o WireGuard no dispositivo
do utilizador, para que este possa estabelecer uma ligação à VPN.


\newpage 
\subsection{Base de Dados}
A base de dados será utilizada para armazenar as informações dos utilizadores, as suas credenciais, bem como as mensagens trocadas entre os utilizadores, esta será implementada utilizando o SQLite.
A base de dados irá ter a seguinte estrutura:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Recursos/ProjectSecure_DB.png}
	\caption{Estrutura da Base de Dados}
	\label{fig:db_structure}
\end{figure}

\newpage 

Sendo que a base de dados é composta por 4 tabelas, cada uma com as suas respetivas colunas,
sendo que as tabelas são:

\begin{minipage}{\textwidth}


    \begin{itemize}

        \item \textbf{User:}
              \begin{itemize}
                  \item UserID (chave primária)
                  \item Username (string)
                  \item Password (string)
              \end{itemize}

        \item \textbf{Chat:}
              \begin{itemize}
                  \item ChatID (chave primária)
                  \item Name (string)
                  \item AdminID (chave estrangeira, referência à tabela User)
              \end{itemize}

        \item \textbf{Participant:}
              \begin{itemize}
                  \item ParticipantID (chave primária)
                  \item ChatID (chave estrangeira, referência à tabela Chat)
                  \item UserID (chave estrangeira, referência à tabela User)
              \end{itemize}
              \newpage
        \item \textbf{Message:}
              \begin{itemize}
                  \item MessageID (chave primária)
                  \item ParticipantID (chave estrangeira, referência à tabela Participant)
                  \item Content (string)
                  \item Date (data e hora da mensagem)
                  \item SenderUserID (chave estrangeira, referência à tabela Participant)
              \end{itemize}
    \end{itemize}


\end{minipage}

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Desenvolvimento}\label{desenvolvimento}
\subsection{Interface para Computador}
Para o desenvolvimento da interface para computador, foi utilizado o Visual Studio Code, que é um ambiente de desenvolvimento integrado (IDE) da Microsoft.

\subsubsection{Ecrã de Login}
O ecrã de login é composto por um formulário onde o utilizador pode inserir as suas credenciais, e um botão para autenticar-se na aplicação.
Caso não tenha uma conta criada apenas tem que preencher o formulario e clicar no botão de criar conta, esta ação só é possivel com o Wireguard ativado.
Também é possivel ver o estado da ligação WireGuard, caso esteja ligado ou desligado.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/LoginPC1.png}
        \caption{WireGuard Ativado}
    \label{fig:login_pc_img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/LoginPC2.png}
        \caption{Wireguard Desativado}
    \label{fig:login_pc_img2}
    \end{subfigure}
    \caption{Ecrã de Login - Computador}
    \label{fig:login_pc_duas_imagens}
\end{figure}

\newpage
\subsubsection{Ecrã de Lista de Chats}
O ecrã de lista de chats é composto por uma lista de chats existentes e um botão para criar novos chats, este só pode ser criado com o WireGuard ativado.
No seu canto superior direito, existe um botão para aceder às definições da aplicação, onde o utilizador pode configurar se quer a aplicação em modo escuro ou claro,
e no seu canto inferior esquerdo existe um botão para terminar sessão caso deseja mudar de utilizador.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ListaPC1.png}
        \caption{WireGuard Ativado}
    \label{fig:lista_pc_img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ListaPC2.png}
        \caption{Wireguard Desativado}
    \label{fig:lista_pc_img2}
    \end{subfigure}
    \caption{Ecrã de Lista de Chats - Computador}
    \label{fig:lista_pc_duas_imagens}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Chat}
O ecrã de chat é composto por uma lista de mensagens trocadas entre os utilizadores, mensagens recebidas ficam do lado esquerdo e mensagens enviadas no lado direito.
Apenas é possivel enviar mensagens com o WireGuard ativado, para enviar uma mensagem basta escrever no campo de texto e clicar no botão de enviar.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ChatPC1.png}
        \caption{WireGuard Ativado}
    \label{fig:chat_pc_img1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{Recursos/ChatPC2.png}
        \caption{Wireguard Desativado}
    \label{fig:chat_pc_img2}
    \end{subfigure}
    \caption{Ecrã de Chat - Computador}
    \label{fig:chat_pc_duas_imagens}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Configuração WireGuard}
O ecrã de configuração WireGuard é composto por um formulário onde o utilizador insere o seu nome, e um botão para descarregar o ficheiro de configuração do WireGuard.
\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{Recursos/WireguardPC.png} % Substitua pelo caminho da imagem
	\label{fig:wireguard_pc}
	\caption{Ecrã de Configuração WireGuard - Computador}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsection{Interface para Android}
Para o desenvolvimento da interface para Android, foi utilizado o Android Studio, que é um ambiente de desenvolvimento integrado 
(IDE) oficial para o sistema operativo Android.
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Login}
O ecrã de login é composto por um formulário onde o utilizador pode inserir as suas credenciais, e um botão para autenticar-se na aplicação. 
Este pode iniciar sessão ou criar uma conta, caso não possua uma. Também é possivel ver o estado da ligação WireGuard, caso esteja ligado 
ou desligado. Existe ainda a possibilidade de estabelecer a comunicação de uma forma mais prática para o utilizador, através do download do 
ficheiro de configuração do WireGuard.

\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/LoginAndroid.png} % Substitua pelo caminho da imagem
    \label{fig:android_login}
    \caption{Ecrã de Login - Android}
    
\end{figure}
\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de configuração do WireGuard}
Neste ecrã, o utilizador pode inserir um nome que está associado à sua ligação WireGuard. Após inserir e enviar o pedido, será 
fornecido o ficheiro de configuração do WireGuard, que pode ser importado diretamente na aplicação do WireGuard no dispositivo Android.

\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/WireguardAndroid.png} % Substitua pelo caminho da imagem
    \label{fig:android_config_wireguard}
    \caption{Ecrã de Configuração do WireGuard - Android}
    
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Lista de Chats}
O ecrã de lista de chats é composto por uma lista de conversas anteriores, onde o utilizador pode selecionar uma conversa para visualizar o seu conteúdo. 
Neste ecrã, também é possível iniciar uma nova conversa, caso o utilizador deseje.
\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/ListaAndroid.png} % Substitua pelo caminho da imagem
    \caption{Lista de Chats - Android}
    \label{fig:android_lista_chats}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsubsection{Ecrã de Chat}
O ecrã de chat é composto por uma lista de mensagens trocadas entre os utilizadores, mensagens recebidas ficam do lado esquerdo e mensagens enviadas no lado direito.
Apenas é possivel enviar mensagens com o WireGuard ativado, para enviar uma mensagem basta escrever no campo de texto e clicar no botão de enviar.
\begin{figure}[h]
    \centering
    \includegraphics[width=6cm]{Recursos/ChatAndroid.png} % Substitua pelo caminho da imagem
    \caption{Ecrã de Chat - Android}
    \label{fig:android_chat}
\end{figure}

\newpage
%-------------------------------------------------------------------------------------------------
\subsection{AlmaOS - Serviço de VPN}
Para configurar corretamente o serviço de VPN, é necessário instalar o WireGuard no servidor AlmaOS 8.10,
para isso ser feito, foi necessário seguir os seguintes passos:
\begin{enumerate}
	\item Adicionar o repositório EPEL - sudo dnf install epel-release
	\item Adicionar o repositório ELREPO - sudo dnf install https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm
	\item Ativar o CodeReady Builder - sudo /usr/bin/crb enable
	\item Atualizar os metadados - sudo dnf makecache
	\item sudo dnf --enablerepo=elrepo install kmod-wireguard -y
	\item Instalar o WireGuardTools - sudo dnf install wireguard-tools -y
\end{enumerate}
Para verificar se o WireGuard está instalado corretamente, pode-se utilizar o comando \textbf{"sudo modprobe wireguard"},
se este não devolver nenhum output, significa que o WireGuard está instalado corretamente.

Agora, para configurar o WireGuard, é necessário criar as chaves de criptografia, para isso é necessário
ir para a pasta \textbf{/etc/wireguard} e executar o seguintes comando:
\begin{verbatim}
    wg genkey | tee server_private.key | wg pubkey > server_public.key
    chmod 600 server_private.key
\end{verbatim}
Isto irá gerar duas chaves, uma privada e uma pública, que serão utilizadas para autenticar os utilizadores na VPN.
\newpage
Após isso, é necessário criar o ficheiro de configuração do WireGuard, onde estará definida a configuração da VPN em si,
como o endereço IP da VPN, a porta de escuta, as chaves de criptografia, entre outros.
Para isso, é necessário criar o ficheiro \textbf{wg0.conf} na pasta \textbf{/etc/wireguard}, e adicionar o seguinte conteúdo:
\begin{verbatim}
    [Interface]
    PrivateKey = <Chave Privada do Servidor>
    Address = 10.0.0.1/24
    ListenPort = 51820
    SaveConfig = true
    [Peer]
    PublicKey = <Chave Pública do Cliente>
    AllowedIPs = 10.0.0.2/32
\end{verbatim}

Para garantir o bom funcionamento da VPN, é necessário ativar o encaminhamento de endereços IP, para assim permitir o tráfego de rede.
Para isso, é necessário fazer o seguinte comando:
\begin{verbatim}
    # Para permitir o tráfego de rede 
    echo "net.ipv4.ip_forward = 1" | sudo tee -a /etc/sysctl.conf
    sudo sysctl -p

    # Para permitir o tráfego pela porta 51820
    sudo firewall-cmd --add-masquerade --permanent
    sudo firewall-cmd --add-port=51820/udp --permanent
    sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o enp0s3 -j MASQUERADE
    sudo firewall-cmd --reload

\end{verbatim}
\newpage
Para ser possível encaminhar o tráfego de rede, é necessário adicionar uma regra ao Router para que, todos os pacotes que cheguem à porta 51820
sejam encaminhados para o servidor WireGuard.
Por fim, basta iniciar o serviço do WireGuard, para isso é necessário executar o seguinte comando:
\begin{verbatim}
    sudo systemctl enable --now wg-quick@wg0
\end{verbatim}

Para conseguir estabelecer a troca de ficheiros entre o servidor e o cliente, foi necessário implementar
um \textit{script} que gerencia as trocas de ficheiros da base de dados entre os clientes e o servidor.
Esse script foi feito em Python, utiliza a biblioteca Flask para criar uma API REST que permite a comunicação entre o cliente e o servidor.
Foi necessário permitir a porta 8000 no servidor, para que o cliente possa comunicar com o servidor.


Do lado do cada cliente, vai ser necessário configurar o WireGuard, de maneira a que apenas a informação
proveniente da aplicação desenvolvida seja enviada através da VPN, onde assim serão poupados recursos
do dispositivo que está a fazer o papel de servidor. Para isso, foi criado um \textit{script} que cria o ficheiro
de configuração do WireGuard para o cliente, sendo que este só deve adicionar o ficheiro de configuração na aplicação
do WireGuard. O \textit{script} ainda automatiza a adição do cliente nas configurações do servidor. Foi criado ainda um 
\textit{script} complementar, em Python, para ser obtido o ficheiro de configurações de maneira mais fácil para o utilizador/cliente. 
Este script segue o mesmo princípio da troca da base de dados, com a diferença de que está a utilizar a seu endereço de IP local em vez 
da VPN. Sendo assim, para obter o ficheiro de configurações, é necessário estabelecer conexão com o servidor no endereço 
\textit{192.168.1.106:9595 {nome}}, onde \textit{nome} é o nome do utilizador que quer aceder à VPN. Ao estabelecer ligação, vai ter 
um ficheiro de configurações criado por um administrador à espera de ser transferido. O administrador cria esse ficheiro com o auxilio do 
\textit{script} anterior, para conseguir limitar o acesso às comunicações caso o acesso à VPN seja comprometido.


\begin{verbatim}
    sudo firewall-cmd --add-port=8000/tcp --permanent
    sudo firewall-cmd --reload
\end{verbatim}

%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Problemas Encontrados}\label{problemas}
Durante o desenvolvimento do projeto, foram encontrados alguns problemas e respetivas soluções. Nas secções seguintes 
apresenta-se um conjunto de problemas e soluções selecionados, pela sua relevância no projeto.
%-------------------------------------------------------------------------------------------------
\subsection{Problemas de Conexão}
Logo no inicio da implementação da VPN foi necessário achar uma solução para a configuração de encaminhamento de pacotes, pois o servidor Linux
não possui um endereço IP público próprio. Para contornar este problema, foi necessário configurar o encaminhamento de pacotes no router, de forma
a que todos os pacotes que chegassem à porta 51820 fossem encaminhados para o servidor Linux, e este resolveria a situação encaminhando o resto dos pacotes pela VPN.\\
Outro problema encontrado foi a dificuldade em encontrar uma maneira para estabelecer a conexão pela primeira vez, ou seja, enviar o ficheiro de configuração
da VPN para o dispositivo do utilizador, de forma a que este pudesse estabelecer a conexão com o servidor. Para resolver este problema,
foi necessário criar um \textit{script} que gerasse o ficheiro de configuração do WireGuard, e que fosse possível enviar esse ficheiro para o dispositivo do utilizador.
%-------------------------------------------------------------------------------------------------
\subsection{Problemas na aplicação Windows/Android}
Durante o desenvolvimento da aplicação, foram encontrados diversos problemas, como por exemplo:
\begin{itemize}
	\item Problemas de compatibilidade entre tipos de base de dados (SQLite e Schemas);
	      \begin{itemize}
		      \item Incompatibilidade de nomes entre tabelas, sendo necessário colocar as tabelas em letra minúscula em ambos. 
              A solução passou por uniformizar a definição das entidades. Exemplo:
              \newpage
\begin{lstlisting}[language=Kotlin, caption={Definição da tabela \texttt{users} em Kotlin}]
@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey
    @ColumnInfo(name = "UserId")
    val userId: String,
    @ColumnInfo(name = "Name")
    val name: String,
    @ColumnInfo(name = "Password")
    val password: String
)
\end{lstlisting}

		      \item Configurações por defeito diferentes entre as plataformas, sendo necessário deixar explícito em ambos os lados 
              sobre as configurações necessárias, como por exemplo \texttt{NOT NULL};
	      \end{itemize}
	\item Permissões do Android, sendo necessário adicionar todas as permissões necessárias no \texttt{AndroidManifest.xml} para funcionar corretamente. 
    A solução foi a inclusão explícita das permissões obrigatórias:
\begin{lstlisting}[language=XML, caption={Permissões no AndroidManifest.xml}]
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.INTERNET" />
\end{lstlisting}

	\item Visualização/sincronização incorreta das informações e a impossibilidade de modificar a base de dados enquanto a aplicação está a correr. 
    Para resolver, foi criada uma base de dados temporária (\textit{snapshot}) através da instrução \texttt{VACUUM INTO}, garantindo consistência sem bloquear a BD principal:
\newpage
    
\begin{lstlisting}[language=Kotlin, caption={Criação de snapshot temporário da base de dados}]
private fun createDatabaseSnapshot(context: Context): File? {
    val dbFile = context.getDatabasePath(DB_NAME)
    if (!dbFile.exists()) return null
    return try {
        val sqlDb = SQLiteDatabase.openDatabase(dbFile.path, null, SQLiteDatabase.OPEN_READWRITE)
        try {
            sqlDb.rawQuery("PRAGMA wal_checkpoint(PASSIVE);", null).close()
            val snapshot = File.createTempFile("upload_snapshot", ".db", context.cacheDir)
            val escaped = snapshot.absolutePath.replace("'", "''")
            sqlDb.execSQL("VACUUM INTO '$escaped'")
            snapshot
        } finally { sqlDb.close() }
    } catch (e: Exception) { null }
}
\end{lstlisting}
\end{itemize}


%-------------------------------------------------------------------------------------------------
\subsection{Depuração da camada criptográfica e protocolo de \textit{framing}}
\label{subsec:cripto-framing}
\subsubsection*{Contexto}
A arquitetura Cliente Android (Kotlin) $\leftrightarrow$ Servidor PC (Python) exige confidencialidade e integridade ponta-a-ponta. 
Foi adotado Serpent-256 em modo AEAD, com AAD a autenticar metadados. 
Durante os testes iniciais surgiram falhas consistentes de decriptação (\texttt{BAD\_DECRYPT}), mesmo com parâmetros aparentemente corretos.

\subsubsection*{Sintomas observados}
\begin{itemize}
    \item Erros repetidos \texttt{BAD\_DECRYPT} antes de qualquer \textit{plaintext} ser obtido.
    \item Comprimento de chave válido (32 bytes), mas divergências estruturais em nonce/tag/AAD.
    \item Envio rápido de duas mensagens consecutivas causava bloqueio ou exceções no recetor.
\end{itemize}

\subsubsection*{Metodologia de depuração}
\begin{enumerate}[label=\alph*)]
    \item Instrumentação com \textit{logs} detalhados (chave, AAD, nonce, tag).
    \item Comparação lado-a-lado (hex/base64) entre cliente e servidor.
    \item Ensaios isolados em \textit{scripts} Python com testes negativos (alteração de 1 byte).
    \item Validação com ferramentas externas (\texttt{openssl}, \texttt{hexdump}).
\end{enumerate}

\subsubsection*{Soluções implementadas}
\paragraph{Normalização do envelope e \textit{framing}}
\begin{itemize}
    \item Definição de contrato binário canónico com prefixo de comprimento de 4 bytes (\textbf{big-endian}).
    \item Estrutura formal: LEN, MAGIC, VER, ALG, FLAGS, SEQ, TIMESTAMP, NONCE, TAG, AAD\_LEN, CT\_LEN, AAD, CIPHERTEXT.
    \item Regras explícitas de endianidade e tamanhos para evitar ambiguidade.
\end{itemize}

Para implementar este modelo, foi criada uma função de encriptação capaz de gerar o envelope
com os campos de \textit{header} autenticados como AAD, garantindo consistência entre cliente e servidor:\newpage

\begin{lstlisting}[language=Kotlin, caption={Função de encriptação com AAD e envelope binário}]
private fun encryptInternal(
    data: ByteArray,
    masterKey: ByteArray,
    salt: ByteArray,
    nonce: ByteArray,
    alg: Alg
): ByteArray {
    val key = deriveKey(masterKey, salt, ITERATIONS)
    val mask = computeAlgMask(masterKey, salt)
    val algXor = (alg.code.toInt() xor (mask.toInt() and 0xFF)).toByte()
    val aad = buildHeader(algXor, ITERATIONS, salt, nonce) // full header is AAD

    val ctWithTag = if (alg == Alg.AES) {
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(
            Cipher.ENCRYPT_MODE,
            SecretKeySpec(key, "AES"),
            GCMParameterSpec(TAG_SIZE * 8, nonce)
        )
        cipher.updateAAD(aad)
        cipher.doFinal(data)
    } else {
        val gcm = GCMBlockCipher(SerpentEngine())
        gcm.init(true, AEADParameters(KeyParameter(key), TAG_SIZE * 8, nonce, aad))
        val out = ByteArray(gcm.getOutputSize(data.size))
        var len = gcm.processBytes(data, 0, data.size, out, 0)
        len += gcm.doFinal(out, len)
        out.copyOf(len)
    }
    return envelope(algXor, salt, nonce, ctWithTag)
}
\end{lstlisting}

\paragraph{Robustez na receção e persistência}
\begin{itemize}
    \item Implementação de \textit{BufferAssembler} para só entregar \textit{frames} completos ao descifrador.
    \item Rejeição de mensagens com SEQ duplicado/regressivo (anti-replay).
    \item Escrita na BD encapsulada em transações atómicas, com acesso serializado por \textit{worker/fila}.
\end{itemize}

\subsubsection*{Resultados e validação}
\begin{itemize}
    \item Eliminação dos erros \texttt{BAD\_DECRYPT} após ráfagas curtas.
    \item \textit{Stress tests} com envios consecutivos (30--250 ms) sem falhas de descifragem nem corrupção da BD.
    \item Critérios de fecho: 0 ocorrências de falha em campanhas prolongadas; 100 envios duplos consecutivos sem \textit{crash}; latência média $< 150$ ms.
\end{itemize}

\paragraph{Caso observado: logs e impacto prático}
Durante a instrumentação foi detetado um padrão de erro quando o servidor tenta decifrar pacotes com Serpent: mensagens como
\texttt{"Serpent compatibility decryption failed: All Serpent compatibility approaches failed"} seguidas de \texttt{BAD\_DECRYPT} aparecem no recetor. Estes sinais correspondem à falha da verificação AEAD — tipicamente causada por divergência nos campos autenticados (AAD), no \textit{nonce} ou por leitura/parsing incorreto do envelope.

\paragraph{Reprodução e efeito sobre a base de dados}
Verificou-se um cenário replicável que provoca corrupção/queda da base de dados no PC quando o cliente Android envia duas mensagens muito próximas em tempo. Exemplo:
\begin{enumerate}
    \item PC: OLA
    \item ANDROID: SUP1
    \item ANDROID: SUP2
\end{enumerate}
Nesse caso o recetor recebe \textit{frames} concatenados ou incompletos, tenta decifrá-los e falha (\texttt{BAD\_DECRYPT}), o que pode conduzir a escrita inválida na base de dados ou a estados em que a BD deixa de responder.

\paragraph{Diagnóstico e medidas imediatas}
\begin{itemize}
    \item Comparação lado-a-lado (hex) de AAD/nonce/tag mostra diferenças entre emissor e recetor quando ocorre a falha.
    \item Reenvio isolado do mesmo envelope normalmente decifra corretamente, pelo que o problema não parece ser corrupção permanente dos bytes.
    \item Condições de corrida no processamento e parsing de \textit{streams} TCP são a causa provável.
\end{itemize}
Medidas imediatas aplicadas:
\begin{itemize}
    \item Forçar processamento sequencial no recetor com um \textit{BufferAssembler}.
    \item Introduzir ACK/backpressure em fases de diagnóstico para evitar ráfagas concorrentes.
    \item Garantir que cada escrita na BD ocorre dentro de transações atómicas para evitar corrupção parcial.
\end{itemize}

\paragraph{Recomendações para correção definitiva}
\begin{itemize}
    \item Implementar o \textit{length-prefix} (4 bytes big-endian) e usar um \textit{BufferAssembler} robusto.
    \item Serializar o acesso à base de dados através de um worker dedicado ou fila de escrita.
    \item Validar comprimentos de AAD/nonce/tag antes de chamar a decriptação.
    \item Assegurar unicidade de nonce por mensagem (ex.: NONCE = prefixo chave || SEQ monotónico).
\end{itemize}

\subsubsection*{Lições aprendidas}
A principal fonte de instabilidade não era apenas a cifra, mas a ausência de um contrato binário formal (layout de envelope + AAD + \textit{framing}). Ao fixar cada campo e a sua semântica, reduziram-se incompatibilidades e simplificou-se a depuração. A unicidade do nonce derivado de \textbf{SEQ} e a instrumentação detalhada foram determinantes para estabilizar o sistema.

\medskip
\textbf{Fundamentação teórica (AEAD, AAD, nonces e framing).}
\begin{itemize}
    \item \textbf{AEAD} combina confidencialidade e integridade: a decriptação falha integralmente se qualquer bit do \textit{ciphertext}, da \textbf{TAG} ou da \textbf{AAD} estiver alterado.
    \item \textbf{AAD} é não cifrada mas autenticada; divergências entre emissor e recetor provocam \texttt{BAD\_DECRYPT}.
    \item O tamanho da \textbf{TAG} (tipicamente 16 bytes) é um compromisso entre segurança e espaço.
    \item \textbf{Nonces/IVs} em modos como GCM/EAX devem ser \emph{únicos por chave}.
\end{itemize}

\textbf{Modos AEAD e requisitos de nonce.}
\begin{itemize}
    \item \textbf{GCM}: nonce recomendado de 96 bits (12 bytes) e unicidade estrita.
    \item \textbf{EAX/OCB}: alternativas com requisitos semelhantes.
    \item \textbf{SIV}: tolera reutilização de nonce, à custa de desempenho.
    \item \textbf{Prática adotada}: NONCE = prefixo derivado da chave || \textbf{SEQ} (12 bytes).
\end{itemize}

\textbf{Derivação e separação de chaves (KDF).}
\begin{itemize}
    \item Utilize \textbf{HKDF} com \textit{salt} e \textit{info} para derivar chaves de sessão.
    \item Separe chaves por função (encrypt, mac, nonce-prefix, etc.).
    \item Considere rotação por tempo ou contagem; registe \textbf{VER}/\textbf{ALG} no envelope.
\end{itemize}

\textbf{Framing em canais de \textit{byte-stream} (TCP).}
\begin{itemize}
    \item TCP pode fragmentar ou coalescer envios; o recetor deve reconstituir \textit{frames} completos.
    \item Um \textbf{length-prefix} fixo (4 bytes big-endian) torna os \textit{frames} auto-delimitados.
    \item Defina \textbf{limites máximos} por \textit{frame} e valide \textbf{LEN}.
\end{itemize}

\textbf{Proteções adicionais.}
\begin{itemize}
    \item \textbf{SEQ} monotónico, janela anti-\textit{replay} e \textbf{TIMESTAMP}.
    \item Comparação de \textbf{TAG} em tempo constante; limpeza de chaves e \textit{buffers} sensíveis.
    \item Erros genéricos no protocolo e \textit{logs} internos detalhados com limitação de taxa.
\end{itemize}

\textbf{Testes e verificação.}
\begin{itemize}
    \item \textbf{Vetores de teste} determinísticos no arranque (\textit{self-test}).
    \item \textbf{Fuzzing} do \textit{BufferAssembler} e do desserializador.
    \item Testes negativos: nonce repetido, TAG truncada, AAD alterada; \textbf{stress tests} com ráfagas e latências variáveis.
\end{itemize}
%---------------------------------------------------------------------------------------------------------------------------

\section{Testes}\label{testes}
Os testes realizados tem como base 2 metodos:
\begin{itemize}
	\item Verificação da base de dados através do servidor
	\item Sniffing das comunicações com o uso do Wireshark
\end{itemize}
%-------------------------------------------------------------------------------------------------
\subsection{Servidor}
Os testes realizados no servidor foram focados na verificação da base de dados e na monitorização das comunicações.
Para a verificação da base de dados, é feita a tentativa de ler o ficheiro enviado, e como é possivel verificar nas figuras abaixo,
ao ler o ficheiro sem criptografia, é possível visualizar o seu conteúdo perfeitamente, ao ler o ficheiro com criptografia,
não é possível visualizar o seu conteúdo pois o servidor guarda a base de dados sem desencriptar, isto leva a que o ficheiro nem seja reconhecido como uma base de dados.
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{Recursos/DBNormal.png}
        \caption{Sem Criptografia}
        \label{fig:db_normal}
    \end{subfigure}
    \vskip 2cm
    \begin{subfigure}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{Recursos/DBEncriptada.png}
        \caption{Com Criptografia}
        \label{fig:db_encriptada}
    \end{subfigure}
    \caption{Teste com Servidor}
    \label{fig:wireshark_msg_duas_imagens}
\end{figure}
\newpage
%-------------------------------------------------------------------------------------------------   
\subsection{Comunicações}
Para a monitorização das comunicações, foi utilizado o Wireshark para fazer sniffing dos pacotes que estavam a ser enviados e recebidos pelo servidor.
Como é possivel ver nas figuras abaixo, estes são os resultados:

\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{1.05\textwidth}
        \includegraphics[width=\textwidth]{Recursos/WiresharkNormalMSG.png}
        \caption{Sem Criptografia}
        \label{fig:wireshark_normal_fora}
    \end{subfigure}

    % Espaço vertical entre as imagens
    \vskip 1cm

    \begin{subfigure}[b]{1.05\textwidth}
        \includegraphics[width=\textwidth]{Recursos/WiresharkEncriptadaMSG.png}
        \caption{Com Criptografia}
        \label{fig:wireshark_encriptado_fora}
    \end{subfigure}
    \caption{Teste com Servidor}
    \label{fig:duas_imagens}
\end{figure}
Para obter esta captura, foi necessário selecionar dentro do Wireshark o adaptador associado à VPN para ver o tráfego que passa lá dentro. Ao analisar o resultado obtido pelo
Wireshark não é possível detetar nenhuma diferença óbvia, sem ser a questão do aparecimento do \textit{(text/html)} nas mensagens criptografadas. 
Isto, só se vai tornar mais visível, quando for selecionada a mensagem, e com o botão direito do rato, selecionar depois a opção \textit{Follow --> TCP Stream},
isto fará com que apareçam os resultados das figuras \ref{fig:wireguard_normal} e \ref{fig:wireguard_encriptado}.

\newpage
Sendo assim, podemos analisar o conteúdo desta mensagem 
HTTP, sendo ele na figura \ref{fig:wireguard_normal} a estrutura da base de dados nas fases iniciais do projeto, onde ainda não estava criptografada. Ao analisar o conteúdo após,
seria possível visualizar todas as informações da base de dados, incluindo utilizadores, mensagens e outros dados sensíveis.
\begin{figure}[h]
        \centering
        \includegraphics[width=0.7\textwidth]{Recursos/WiresharkNormal.png}
        \caption{Wireshark Sem Criptografia}
        \label{fig:wireguard_normal}
\end{figure}
\newpage
Agora, ao analisar o conteúdo da figura \ref{fig:wireguard_encriptado}, podemos ver que a estrutura da base de dados está ilegível para um
ser humano devido à criptografia AES256/Serpent, sendo impossível saber o conteúdo se não for feita a decriptação, e para isto ocorrer 
é necessário ter acesso à chave, seja para "desenvolopar", seja para desencriptar. Isto garante a segurança 
das comunicações caso o acesso à VPN seja comprometido, e uma pessoa não autorizada consiga aceder ao tráfego que passa pela VPN.
\begin{figure}[h]
    \centering
        \includegraphics[width=0.7\textwidth]{Recursos/WiresharkEncriptada.png}
        \caption{Wireshark Com Criptografia}
        \label{fig:wireguard_encriptado}
\end{figure}


%---------------------------------------------------------------------------------------------------------------------------
\section{Melhorias Futuras}
Este projeto está sujeito a imensas melhorias, tais como:
\begin{itemize}
    \item Implementação de novas funcionalidades, como mensagens de voz/chamadas criptografadas;
    \item Melhoria da interface do utilizador;
    \item Aumento da segurança das comunicações, adicionando HTTPS em vez de HTTP.
\end{itemize}
%---------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Conclusão}\label{con}
Concluimos assim que o projeto foi um sucesso, pois conseguimos desenvolver um sistema de comunicações seguras
que permite a troca de mensagens de texto entre os seus utilizadores, sem que haja a possibilidade de terceiros acederem às mensagens trocadas.
Em geral, foi um projeto que nos permitiu aprender bastante sobre a área de cibersegurança e comunicações seguras, 
sendo que a implementação de uma VPN com o WireGuard foi um desafio interessante e que nos permitiu aprender bastante sobre o funcionamento das VPNs.
Além do enorme desafio que foi implementar a camada da criptografia, e fazê-la funcionar corretamente entre dois sistemas operativos diferentes (Android e Windows), e 
ainda com linguagens de programação diferentes (C\# e Kotlin).

Foi necessário aprender bastante sobre criptografia, servidores, redes e protocolos de comunicação, 
e foi importante também para aprender a trabalhar em equipa, e separar as tarefas de maneira eficiente, para que tudo fosse feito dentro do prazo estipulado e sem 
sobrecarregar nenhum dos elementos da equipa. Este projeto não só reforçou as nossas competências técnicas e de colaboração, como também contribuiu para uma 
solução que pode servir de base a futuras melhorias e aplicações em ambientes reais.

\section{Agradecimentos}\label{agradecimentos}
Gostaríamos de agradecer ao professor Rui Miguel Soares Silva pela sua disponibilidade para dar opiniões e ajudar durante o projeto, assim como aos nossos colegas de turma pelo apoio e 
colaboração.
%---------------------------------------------------------------------------------------------------------------------------

\newpage
\renewcommand{\refname}{Bibliografia} % Para artigos
\renewcommand{\bibname}{Bibliografia} % Para livros e relatórios
\addcontentsline{toc}{section}{Bibliografia} % Adiciona a Bibliografia ao índice
\printbibliography
\newpage
\end{document}
